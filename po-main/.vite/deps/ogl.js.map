{
  "version": 3,
  "sources": ["../../node_modules/ogl/src/math/functions/Vec3Func.js", "../../node_modules/ogl/src/math/Vec3.js", "../../node_modules/ogl/src/core/Geometry.js", "../../node_modules/ogl/src/core/Program.js", "../../node_modules/ogl/src/core/Renderer.js", "../../node_modules/ogl/src/math/functions/Vec4Func.js", "../../node_modules/ogl/src/math/functions/QuatFunc.js", "../../node_modules/ogl/src/math/Quat.js", "../../node_modules/ogl/src/math/functions/Mat4Func.js", "../../node_modules/ogl/src/math/Mat4.js", "../../node_modules/ogl/src/math/functions/EulerFunc.js", "../../node_modules/ogl/src/math/Euler.js", "../../node_modules/ogl/src/core/Transform.js", "../../node_modules/ogl/src/core/Camera.js", "../../node_modules/ogl/src/math/functions/Mat3Func.js", "../../node_modules/ogl/src/math/Mat3.js", "../../node_modules/ogl/src/core/Mesh.js", "../../node_modules/ogl/src/core/Texture.js", "../../node_modules/ogl/src/core/RenderTarget.js", "../../node_modules/ogl/src/math/functions/ColorFunc.js", "../../node_modules/ogl/src/math/Color.js", "../../node_modules/ogl/src/math/functions/Vec2Func.js", "../../node_modules/ogl/src/math/Vec2.js", "../../node_modules/ogl/src/math/Vec4.js", "../../node_modules/ogl/src/extras/Plane.js", "../../node_modules/ogl/src/extras/Box.js", "../../node_modules/ogl/src/extras/Sphere.js", "../../node_modules/ogl/src/extras/Cylinder.js", "../../node_modules/ogl/src/extras/Triangle.js", "../../node_modules/ogl/src/extras/Torus.js", "../../node_modules/ogl/src/extras/Orbit.js", "../../node_modules/ogl/src/extras/Raycast.js", "../../node_modules/ogl/src/extras/Curve.js", "../../node_modules/ogl/src/extras/path/BaseSegment.js", "../../node_modules/ogl/src/extras/path/utils.js", "../../node_modules/ogl/src/extras/path/CubicBezierSegment.js", "../../node_modules/ogl/src/extras/path/QuadraticBezierSegment.js", "../../node_modules/ogl/src/extras/path/LineSegment.js", "../../node_modules/ogl/src/extras/path/Path.js", "../../node_modules/ogl/src/extras/Tube.js", "../../node_modules/ogl/src/extras/Post.js", "../../node_modules/ogl/src/extras/Animation.js", "../../node_modules/ogl/src/extras/Skin.js", "../../node_modules/ogl/src/extras/Text.js", "../../node_modules/ogl/src/extras/NormalProgram.js", "../../node_modules/ogl/src/extras/Flowmap.js", "../../node_modules/ogl/src/extras/GPGPU.js", "../../node_modules/ogl/src/extras/Polyline.js", "../../node_modules/ogl/src/extras/Shadow.js", "../../node_modules/ogl/src/extras/KTXTexture.js", "../../node_modules/ogl/src/extras/TextureLoader.js", "../../node_modules/ogl/src/extras/GLTFAnimation.js", "../../node_modules/ogl/src/extras/GLTFSkin.js", "../../node_modules/ogl/src/extras/InstancedMesh.js", "../../node_modules/ogl/src/extras/GLTFLoader.js", "../../node_modules/ogl/src/extras/DracoManager.js", "../../node_modules/ogl/src/extras/BasisManager.js", "../../node_modules/ogl/src/extras/WireMesh.js", "../../node_modules/ogl/src/extras/helpers/AxesHelper.js", "../../node_modules/ogl/src/extras/helpers/GridHelper.js", "../../node_modules/ogl/src/extras/helpers/VertexNormalsHelper.js", "../../node_modules/ogl/src/extras/helpers/FaceNormalsHelper.js", "../../node_modules/ogl/src/extras/Texture3D.js"],
  "sourcesContent": ["const EPSILON = 0.000001;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    out[2] = 1.0 / a[2];\n    return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec3} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    out[2] = b[2] + (az - b[2]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n}\n\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */\nexport function scaleRotateMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let qx = q[0],\n        qy = q[1],\n        qz = q[2],\n        qw = q[3];\n\n    let uvx = qy * z - qz * y;\n    let uvy = qz * x - qx * z;\n    let uvz = qx * y - qy * x;\n\n    let uuvx = qy * uvz - qz * uvy;\n    let uuvy = qz * uvx - qx * uvz;\n    let uuvz = qx * uvy - qy * uvx;\n\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport const angle = (function () {\n    const tempA = [0, 0, 0];\n    const tempB = [0, 0, 0];\n\n    return function (a, b) {\n        copy(tempA, a);\n        copy(tempB, b);\n\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n\n        let cosine = dot(tempA, tempB);\n\n        if (cosine > 1.0) {\n            return 0;\n        } else if (cosine < -1.0) {\n            return Math.PI;\n        } else {\n            return Math.acos(cosine);\n        }\n    };\n})();\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n", "import * as Vec3Func from './functions/Vec3Func.js';\n\nexport class Vec3 extends Array {\n    constructor(x = 0, y = x, z = x) {\n        super(x, y, z);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        Vec3Func.set(this, x, y, z);\n        return this;\n    }\n\n    copy(v) {\n        Vec3Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec3Func.add(this, va, vb);\n        else Vec3Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec3Func.subtract(this, va, vb);\n        else Vec3Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec3Func.multiply(this, this, v);\n        else Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec3Func.divide(this, this, v);\n        else Vec3Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec3Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec3Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec3Func.distance(this, v);\n        else return Vec3Func.length(this);\n    }\n\n    squaredLen() {\n        return Vec3Func.squaredLength(this);\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec3Func.squaredDistance(this, v);\n        else return Vec3Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec3Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) Vec3Func.cross(this, va, vb);\n        else Vec3Func.cross(this, this, va);\n        return this;\n    }\n\n    scale(v) {\n        Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec3Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec3Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec3Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec3Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec3Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    scaleRotateMatrix4(mat4) {\n        Vec3Func.scaleRotateMat4(this, this, mat4);\n        return this;\n    }\n\n    applyQuaternion(q) {\n        Vec3Func.transformQuat(this, this, q);\n        return this;\n    }\n\n    angle(v) {\n        return Vec3Func.angle(this, v);\n    }\n\n    lerp(v, t) {\n        Vec3Func.lerp(this, this, v, t);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec3Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec3(this[0], this[1], this[2]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n\n    transformDirection(mat4) {\n        const x = this[0];\n        const y = this[1];\n        const z = this[2];\n\n        this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n        this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n        this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n\n        return this.normalize();\n    }\n}\n", "// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\n                );\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n", "// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\n\nlet ID = 1;\n\n// cache of typed arrays used to flatten uniform arrays\nconst arrayCacheF32 = {};\n\nexport class Program {\n    constructor(\n        gl,\n        {\n            vertex,\n            fragment,\n            uniforms = {},\n\n            transparent = false,\n            cullFace = gl.BACK,\n            frontFace = gl.CCW,\n            depthTest = true,\n            depthWrite = true,\n            depthFunc = gl.LEQUAL,\n        } = {}\n    ) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Program');\n        this.gl = gl;\n        this.uniforms = uniforms;\n        this.id = ID++;\n\n        if (!vertex) console.warn('vertex shader not supplied');\n        if (!fragment) console.warn('fragment shader not supplied');\n\n        // Store program state\n        this.transparent = transparent;\n        this.cullFace = cullFace;\n        this.frontFace = frontFace;\n        this.depthTest = depthTest;\n        this.depthWrite = depthWrite;\n        this.depthFunc = depthFunc;\n        this.blendFunc = {};\n        this.blendEquation = {};\n        this.stencilFunc = {};\n        this.stencilOp = {}\n\n        // set default blendFunc if transparent flagged\n        if (this.transparent && !this.blendFunc.src) {\n            if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n            else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        }\n\n        // Create empty shaders and attach to program\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vertexShader);\n        gl.attachShader(this.program, this.fragmentShader);\n\n        // Compile shaders with source\n        this.setShaders({ vertex, fragment });\n    }\n\n    setShaders({ vertex, fragment }) {\n        if (vertex) {\n            // compile vertex shader and log errors\n            this.gl.shaderSource(this.vertexShader, vertex);\n            this.gl.compileShader(this.vertexShader);\n            if (this.gl.getShaderInfoLog(this.vertexShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n            }\n        }\n\n        if (fragment) {\n            // compile fragment shader and log errors\n            this.gl.shaderSource(this.fragmentShader, fragment);\n            this.gl.compileShader(this.fragmentShader);\n            if (this.gl.getShaderInfoLog(this.fragmentShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n            }\n        }\n\n        // compile program and log errors\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            return console.warn(this.gl.getProgramInfoLog(this.program));\n        }\n\n        // Get active uniform locations\n        this.uniformLocations = new Map();\n        let numUniforms = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);\n        for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n            let uniform = this.gl.getActiveUniform(this.program, uIndex);\n            this.uniformLocations.set(uniform, this.gl.getUniformLocation(this.program, uniform.name));\n\n            // split uniforms' names to separate array and struct declarations\n            const split = uniform.name.match(/(\\w+)/g);\n\n            uniform.uniformName = split[0];\n            uniform.nameComponents = split.slice(1);\n        }\n\n        // Get active attribute locations\n        this.attributeLocations = new Map();\n        const locations = [];\n        const numAttribs = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);\n        for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n            const attribute = this.gl.getActiveAttrib(this.program, aIndex);\n            const location = this.gl.getAttribLocation(this.program, attribute.name);\n            // Ignore special built-in inputs. eg gl_VertexID, gl_InstanceID\n            if (location === -1) continue;\n            locations[location] = attribute.name;\n            this.attributeLocations.set(attribute, location);\n        }\n        this.attributeOrder = locations.join('');\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        this.blendFunc.src = src;\n        this.blendFunc.dst = dst;\n        this.blendFunc.srcAlpha = srcAlpha;\n        this.blendFunc.dstAlpha = dstAlpha;\n        if (src) this.transparent = true;\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        this.blendEquation.modeRGB = modeRGB;\n        this.blendEquation.modeAlpha = modeAlpha;\n    }\n\n    setStencilFunc(func, ref, mask) {\n        this.stencilRef = ref;\n        this.stencilFunc.func = func;\n        this.stencilFunc.ref = ref;\n        this.stencilFunc.mask = mask;\n    }\n\n    setStencilOp(stencilFail, depthFail, depthPass) {\n        this.stencilOp.stencilFail = stencilFail;\n        this.stencilOp.depthFail = depthFail;\n        this.stencilOp.depthPass = depthPass;\n    }\n\n    applyState() {\n        if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);\n        else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n\n        if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);\n        else this.gl.renderer.disable(this.gl.CULL_FACE);\n\n        if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);\n        else this.gl.renderer.disable(this.gl.BLEND);\n\n        if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n        this.gl.renderer.setFrontFace(this.frontFace);\n        this.gl.renderer.setDepthMask(this.depthWrite);\n        this.gl.renderer.setDepthFunc(this.depthFunc);\n        if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n        this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n\n        if(this.stencilFunc.func || this.stencilOp.stencilFail) this.gl.renderer.enable(this.gl.STENCIL_TEST)\n            else this.gl.renderer.disable(this.gl.STENCIL_TEST)\n\n        this.gl.renderer.setStencilFunc(this.stencilFunc.func, this.stencilFunc.ref, this.stencilFunc.mask)\n        this.gl.renderer.setStencilOp(this.stencilOp.stencilFail, this.stencilOp.depthFail, this.stencilOp.depthPass)\n\n    }\n\n    use({ flipFaces = false } = {}) {\n        let textureUnit = -1;\n        const programActive = this.gl.renderer.state.currentProgram === this.id;\n\n        // Avoid gl call if program already in use\n        if (!programActive) {\n            this.gl.useProgram(this.program);\n            this.gl.renderer.state.currentProgram = this.id;\n        }\n\n        // Set only the active uniforms found in the shader\n        this.uniformLocations.forEach((location, activeUniform) => {\n            let uniform = this.uniforms[activeUniform.uniformName];\n\n            for (const component of activeUniform.nameComponents) {\n                if (!uniform) break;\n\n                if (component in uniform) {\n                    uniform = uniform[component];\n                } else if (Array.isArray(uniform.value)) {\n                    break;\n                } else {\n                    uniform = undefined;\n                    break;\n                }\n            }\n\n            if (!uniform) {\n                return warn(`Active uniform ${activeUniform.name} has not been supplied`);\n            }\n\n            if (uniform && uniform.value === undefined) {\n                return warn(`${activeUniform.name} uniform is missing a value parameter`);\n            }\n\n            if (uniform.value.texture) {\n                textureUnit = textureUnit + 1;\n\n                // Check if texture needs to be updated\n                uniform.value.update(textureUnit);\n                return setUniform(this.gl, activeUniform.type, location, textureUnit);\n            }\n\n            // For texture arrays, set uniform as an array of texture units instead of just one\n            if (uniform.value.length && uniform.value[0].texture) {\n                const textureUnits = [];\n                uniform.value.forEach((value) => {\n                    textureUnit = textureUnit + 1;\n                    value.update(textureUnit);\n                    textureUnits.push(textureUnit);\n                });\n\n                return setUniform(this.gl, activeUniform.type, location, textureUnits);\n            }\n\n            setUniform(this.gl, activeUniform.type, location, uniform.value);\n        });\n\n        this.applyState();\n        if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n    }\n\n    remove() {\n        this.gl.deleteProgram(this.program);\n    }\n}\n\nfunction setUniform(gl, type, location, value) {\n    value = value.length ? flatten(value) : value;\n    const setValue = gl.renderer.state.uniformLocations.get(location);\n\n    // Avoid redundant uniform commands\n    if (value.length) {\n        if (setValue === undefined || setValue.length !== value.length) {\n            // clone array to store as cache\n            gl.renderer.state.uniformLocations.set(location, value.slice(0));\n        } else {\n            if (arraysEqual(setValue, value)) return;\n\n            // Update cached array values\n            setValue.set ? setValue.set(value) : setArray(setValue, value);\n            gl.renderer.state.uniformLocations.set(location, setValue);\n        }\n    } else {\n        if (setValue === value) return;\n        gl.renderer.state.uniformLocations.set(location, value);\n    }\n\n    switch (type) {\n        case 5126:\n            return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value); // FLOAT\n        case 35664:\n            return gl.uniform2fv(location, value); // FLOAT_VEC2\n        case 35665:\n            return gl.uniform3fv(location, value); // FLOAT_VEC3\n        case 35666:\n            return gl.uniform4fv(location, value); // FLOAT_VEC4\n        case 35670: // BOOL\n        case 5124: // INT\n        case 35678: // SAMPLER_2D\n        case 36306: // U_SAMPLER_2D\n        case 35680: // SAMPLER_CUBE\n        case 36289: // SAMPLER_2D_ARRAY\n            return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value); // SAMPLER_CUBE\n        case 35671: // BOOL_VEC2\n        case 35667:\n            return gl.uniform2iv(location, value); // INT_VEC2\n        case 35672: // BOOL_VEC3\n        case 35668:\n            return gl.uniform3iv(location, value); // INT_VEC3\n        case 35673: // BOOL_VEC4\n        case 35669:\n            return gl.uniform4iv(location, value); // INT_VEC4\n        case 35674:\n            return gl.uniformMatrix2fv(location, false, value); // FLOAT_MAT2\n        case 35675:\n            return gl.uniformMatrix3fv(location, false, value); // FLOAT_MAT3\n        case 35676:\n            return gl.uniformMatrix4fv(location, false, value); // FLOAT_MAT4\n    }\n}\n\nfunction addLineNumbers(string) {\n    let lines = string.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n        lines[i] = i + 1 + ': ' + lines[i];\n    }\n    return lines.join('\\n');\n}\n\nfunction flatten(a) {\n    const arrayLen = a.length;\n    const valueLen = a[0].length;\n    if (valueLen === undefined) return a;\n    const length = arrayLen * valueLen;\n    let value = arrayCacheF32[length];\n    if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n    for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n    return value;\n}\n\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nfunction setArray(a, b) {\n    for (let i = 0, l = a.length; i < l; i++) {\n        a[i] = b[i];\n    }\n}\n\nlet warnCount = 0;\nfunction warn(message) {\n    if (warnCount > 100) return;\n    console.warn(message);\n    warnCount++;\n    if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n", "import { Vec3 } from '../math/Vec3.js';\n\n// TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nlet ID = 1;\n\nexport class Renderer {\n    constructor({\n        canvas = document.createElement('canvas'),\n        width = 300,\n        height = 150,\n        dpr = 1,\n        alpha = false,\n        depth = true,\n        stencil = false,\n        antialias = false,\n        premultipliedAlpha = false,\n        preserveDrawingBuffer = false,\n        powerPreference = 'default',\n        autoClear = true,\n        webgl = 2,\n    } = {}) {\n        const attributes = { alpha, depth, stencil, antialias, premultipliedAlpha, preserveDrawingBuffer, powerPreference };\n        this.dpr = dpr;\n        this.alpha = alpha;\n        this.color = true;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.premultipliedAlpha = premultipliedAlpha;\n        this.autoClear = autoClear;\n        this.id = ID++;\n\n        // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n        if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n        this.isWebgl2 = !!this.gl;\n        if (!this.gl) this.gl = canvas.getContext('webgl', attributes);\n        if (!this.gl) console.error('unable to create webgl context');\n\n        // Attach renderer to gl so that all classes have access to internal state functions\n        this.gl.renderer = this;\n\n        // initialise size values\n        this.setSize(width, height);\n\n        // gl state stores to avoid redundant calls on methods used internally\n        this.state = {};\n        this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO };\n        this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD };\n        this.state.cullFace = false;\n        this.state.frontFace = this.gl.CCW;\n        this.state.depthMask = true;\n        this.state.depthFunc = this.gl.LEQUAL;\n        this.state.premultiplyAlpha = false;\n        this.state.flipY = false;\n        this.state.unpackAlignment = 4;\n        this.state.framebuffer = null;\n        this.state.viewport = { x: 0, y: 0, width: null, height: null };\n        this.state.textureUnits = [];\n        this.state.activeTextureUnit = 0;\n        this.state.boundBuffer = null;\n        this.state.uniformLocations = new Map();\n        this.state.currentProgram = null;\n\n        // store requested extensions\n        this.extensions = {};\n\n        // Initialise extra format types\n        if (this.isWebgl2) {\n            this.getExtension('EXT_color_buffer_float');\n            this.getExtension('OES_texture_float_linear');\n        } else {\n            this.getExtension('OES_texture_float');\n            this.getExtension('OES_texture_float_linear');\n            this.getExtension('OES_texture_half_float');\n            this.getExtension('OES_texture_half_float_linear');\n            this.getExtension('OES_element_index_uint');\n            this.getExtension('OES_standard_derivatives');\n            this.getExtension('EXT_sRGB');\n            this.getExtension('WEBGL_depth_texture');\n            this.getExtension('WEBGL_draw_buffers');\n        }\n        this.getExtension('WEBGL_compressed_texture_astc');\n        this.getExtension('EXT_texture_compression_bptc');\n        this.getExtension('WEBGL_compressed_texture_s3tc');\n        this.getExtension('WEBGL_compressed_texture_etc1');\n        this.getExtension('WEBGL_compressed_texture_pvrtc');\n        this.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\n        // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n        this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n        this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n        this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n        this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n        this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n        this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n        this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL');\n\n        // Store device parameters\n        this.parameters = {};\n        this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic')\n            ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT)\n            : 0;\n    }\n\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this.gl.canvas.width = width * this.dpr;\n        this.gl.canvas.height = height * this.dpr;\n\n        if (!this.gl.canvas.style) return;\n        Object.assign(this.gl.canvas.style, {\n            width: width + 'px',\n            height: height + 'px',\n        });\n    }\n\n    setViewport(width, height, x = 0, y = 0) {\n        if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n        this.state.viewport.width = width;\n        this.state.viewport.height = height;\n        this.state.viewport.x = x;\n        this.state.viewport.y = y;\n        this.gl.viewport(x, y, width, height);\n    }\n\n    setScissor(width, height, x = 0, y = 0) {\n        this.gl.scissor(x, y, width, height);\n    }\n\n    enable(id) {\n        if (this.state[id] === true) return;\n        this.gl.enable(id);\n        this.state[id] = true;\n    }\n\n    disable(id) {\n        if (this.state[id] === false) return;\n        this.gl.disable(id);\n        this.state[id] = false;\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        if (\n            this.state.blendFunc.src === src &&\n            this.state.blendFunc.dst === dst &&\n            this.state.blendFunc.srcAlpha === srcAlpha &&\n            this.state.blendFunc.dstAlpha === dstAlpha\n        )\n            return;\n        this.state.blendFunc.src = src;\n        this.state.blendFunc.dst = dst;\n        this.state.blendFunc.srcAlpha = srcAlpha;\n        this.state.blendFunc.dstAlpha = dstAlpha;\n        if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);\n        else this.gl.blendFunc(src, dst);\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        modeRGB = modeRGB || this.gl.FUNC_ADD;\n        if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n        this.state.blendEquation.modeRGB = modeRGB;\n        this.state.blendEquation.modeAlpha = modeAlpha;\n        if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);\n        else this.gl.blendEquation(modeRGB);\n    }\n\n    setCullFace(value) {\n        if (this.state.cullFace === value) return;\n        this.state.cullFace = value;\n        this.gl.cullFace(value);\n    }\n\n    setFrontFace(value) {\n        if (this.state.frontFace === value) return;\n        this.state.frontFace = value;\n        this.gl.frontFace(value);\n    }\n\n    setDepthMask(value) {\n        if (this.state.depthMask === value) return;\n        this.state.depthMask = value;\n        this.gl.depthMask(value);\n    }\n\n    setDepthFunc(value) {\n        if (this.state.depthFunc === value) return;\n        this.state.depthFunc = value;\n        this.gl.depthFunc(value);\n    }\n\n    setStencilMask(value) {\n        if(this.state.stencilMask === value) return;\n        this.state.stencilMask = value;\n        this.gl.stencilMask(value)\n    }\n\n    setStencilFunc(func, ref, mask) {\n\n        if((this.state.stencilFunc === func) &&\n            (this.state.stencilRef === ref) &&\n            (this.state.stencilFuncMask === mask)\n        ) return;\n\n        this.state.stencilFunc = func || this.gl.ALWAYS;\n        this.state.stencilRef = ref || 0;\n        this.state.stencilFuncMask = mask || 0;\n\n        this.gl.stencilFunc(func || this.gl.ALWAYS, ref || 0, mask || 0);\n    }\n\n    setStencilOp(stencilFail, depthFail, depthPass) {\n\n        if(this.state.stencilFail === stencilFail &&\n            this.state.stencilDepthFail === depthFail &&\n            this.state.stencilDepthPass === depthPass\n        ) return;\n\n        this.state.stencilFail = stencilFail;\n        this.state.stencilDepthFail = depthFail;\n        this.state.stencilDepthPass = depthPass;\n        \n        this.gl.stencilOp(stencilFail, depthFail, depthPass);\n        \n    }\n\n    activeTexture(value) {\n        if (this.state.activeTextureUnit === value) return;\n        this.state.activeTextureUnit = value;\n        this.gl.activeTexture(this.gl.TEXTURE0 + value);\n    }\n\n    bindFramebuffer({ target = this.gl.FRAMEBUFFER, buffer = null } = {}) {\n        if (this.state.framebuffer === buffer) return;\n        this.state.framebuffer = buffer;\n        this.gl.bindFramebuffer(target, buffer);\n    }\n\n    getExtension(extension, webgl2Func, extFunc) {\n        // if webgl2 function supported, return func bound to gl context\n        if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl);\n\n        // fetch extension once only\n        if (!this.extensions[extension]) {\n            this.extensions[extension] = this.gl.getExtension(extension);\n        }\n\n        // return extension if no function requested\n        if (!webgl2Func) return this.extensions[extension];\n\n        // Return null if extension not supported\n        if (!this.extensions[extension]) return null;\n\n        // return extension function, bound to extension\n        return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n    }\n\n    sortOpaque(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else if (a.zDepth !== b.zDepth) {\n            return a.zDepth - b.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortTransparent(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        }\n        if (a.zDepth !== b.zDepth) {\n            return b.zDepth - a.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortUI(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    getRenderList({ scene, camera, frustumCull, sort }) {\n        let renderList = [];\n\n        if (camera && frustumCull) camera.updateFrustum();\n\n        // Get visible\n        scene.traverse((node) => {\n            if (!node.visible) return true;\n            if (!node.draw) return;\n\n            if (frustumCull && node.frustumCulled && camera) {\n                if (!camera.frustumIntersectsMesh(node)) return;\n            }\n\n            renderList.push(node);\n        });\n\n        if (sort) {\n            const opaque = [];\n            const transparent = []; // depthTest true\n            const ui = []; // depthTest false\n\n            renderList.forEach((node) => {\n                // Split into the 3 render groups\n                if (!node.program.transparent) {\n                    opaque.push(node);\n                } else if (node.program.depthTest) {\n                    transparent.push(node);\n                } else {\n                    ui.push(node);\n                }\n\n                node.zDepth = 0;\n\n                // Only calculate z-depth if renderOrder unset and depthTest is true\n                if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return;\n\n                // update z-depth\n                node.worldMatrix.getTranslation(tempVec3);\n                tempVec3.applyMatrix4(camera.projectionViewMatrix);\n                node.zDepth = tempVec3.z;\n            });\n\n            opaque.sort(this.sortOpaque);\n            transparent.sort(this.sortTransparent);\n            ui.sort(this.sortUI);\n\n            renderList = opaque.concat(transparent, ui);\n        }\n\n        return renderList;\n    }\n\n    render({ scene, camera, target = null, update = true, sort = true, frustumCull = true, clear }) {\n        if (target === null) {\n            // make sure no render target bound so draws to canvas\n            this.bindFramebuffer();\n            this.setViewport(this.width * this.dpr, this.height * this.dpr);\n        } else {\n            // bind supplied render target and update viewport\n            this.bindFramebuffer(target);\n            this.setViewport(target.width, target.height);\n        }\n\n        if (clear || (this.autoClear && clear !== false)) {\n            // Ensure depth buffer writing is enabled so it can be cleared\n            if (this.depth && (!target || target.depth)) {\n                this.enable(this.gl.DEPTH_TEST);\n                this.setDepthMask(true);\n            }\n\n            // Same for stencil\n            if(this.stencil || (!target || target.stencil)) {\n                this.enable(this.gl.STENCIL_TEST);\n                this.setStencilMask(0xff)\n            }\n\n            this.gl.clear(\n                (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |\n                    (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |\n                    (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)\n            );\n        }\n\n        // updates all scene graph matrices\n        if (update) scene.updateMatrixWorld();\n\n        // Update camera separately, in case not in scene graph\n        if (camera) camera.updateMatrixWorld();\n\n        // Get render list - entails culling and sorting\n        const renderList = this.getRenderList({ scene, camera, frustumCull, sort });\n\n        renderList.forEach((node) => {\n            node.draw({ camera });\n        });\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    let len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    let aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n}\n", "import * as vec4 from './Vec4Func.js';\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n}\n\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let by = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bz = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n\n    return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n    let a0 = a[0],\n        a1 = a[1],\n        a2 = a[2],\n        a3 = a[3];\n    let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    let invDot = dot ? 1.0 / dot : 0;\n\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        let j = (i + 1) % 3;\n        let k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, euler, order = 'YXZ') {\n    let sx = Math.sin(euler[0] * 0.5);\n    let cx = Math.cos(euler[0] * 0.5);\n    let sy = Math.sin(euler[1] * 0.5);\n    let cy = Math.cos(euler[1] * 0.5);\n    let sz = Math.sin(euler[2] * 0.5);\n    let cz = Math.cos(euler[2] * 0.5);\n\n    if (order === 'XYZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'YXZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'ZXY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'ZYX') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'YZX') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'XZY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    }\n\n    return out;\n}\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize;\n", "import * as QuatFunc from './functions/QuatFunc.js';\n\nexport class Quat extends Array {\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        super(x, y, z, w);\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2', '3'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set w(v) {\n        this._target[3] = v;\n        this.onChange();\n    }\n\n    identity() {\n        QuatFunc.identity(this._target);\n        this.onChange();\n        return this;\n    }\n\n    set(x, y, z, w) {\n        if (x.length) return this.copy(x);\n        QuatFunc.set(this._target, x, y, z, w);\n        this.onChange();\n        return this;\n    }\n\n    rotateX(a) {\n        QuatFunc.rotateX(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateY(a) {\n        QuatFunc.rotateY(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateZ(a) {\n        QuatFunc.rotateZ(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    inverse(q = this._target) {\n        QuatFunc.invert(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    conjugate(q = this._target) {\n        QuatFunc.conjugate(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    copy(q) {\n        QuatFunc.copy(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    normalize(q = this._target) {\n        QuatFunc.normalize(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    multiply(qA, qB) {\n        if (qB) {\n            QuatFunc.multiply(this._target, qA, qB);\n        } else {\n            QuatFunc.multiply(this._target, this._target, qA);\n        }\n        this.onChange();\n        return this;\n    }\n\n    dot(v) {\n        return QuatFunc.dot(this._target, v);\n    }\n\n    fromMatrix3(matrix3) {\n        QuatFunc.fromMat3(this._target, matrix3);\n        this.onChange();\n        return this;\n    }\n\n    fromEuler(euler, isInternal) {\n        QuatFunc.fromEuler(this._target, euler, euler.order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromAxisAngle(axis, a) {\n        QuatFunc.setAxisAngle(this._target, axis, a);\n        this.onChange();\n        return this;\n    }\n\n    slerp(q, t) {\n        QuatFunc.slerp(this._target, this._target, q, t);\n        this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        this._target[3] = a[o + 3];\n        this.onChange();\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n", "import * as vec3 from './Vec3Func.js';\n\nconst EPSILON = 0.000001;\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a03 = a[3];\n        let a12 = a[6],\n            a13 = a[7];\n        let a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[0],\n        b1 = b[1],\n        b2 = b[2],\n        b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out, a, rad, axis) {\n    let x = axis[0],\n        y = axis[1],\n        z = axis[2];\n    let len = Math.hypot(x, y, z);\n    let s, c, t;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    let b00, b01, b02;\n    let b10, b11, b12;\n    let b20, b21, b22;\n\n    if (Math.abs(len) < EPSILON) {\n        return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) {\n        // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n\n    return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n\n    return out;\n}\n\nexport function getMaxScaleOnAxis(mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    const x = m11 * m11 + m12 * m12 + m13 * m13;\n    const y = m21 * m21 + m22 * m22 + m23 * m23;\n    const z = m31 * m31 + m32 * m32 + m33 * m33;\n\n    return Math.sqrt(Math.max(x, y, z));\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport const getRotation = (function () {\n    const temp = [1, 1, 1];\n\n    return function (out, mat) {\n        let scaling = temp;\n        getScaling(scaling, mat);\n\n        let is1 = 1 / scaling[0];\n        let is2 = 1 / scaling[1];\n        let is3 = 1 / scaling[2];\n\n        let sm11 = mat[0] * is1;\n        let sm12 = mat[1] * is2;\n        let sm13 = mat[2] * is3;\n        let sm21 = mat[4] * is1;\n        let sm22 = mat[5] * is2;\n        let sm23 = mat[6] * is3;\n        let sm31 = mat[8] * is1;\n        let sm32 = mat[9] * is2;\n        let sm33 = mat[10] * is3;\n\n        let trace = sm11 + sm22 + sm33;\n        let S = 0;\n\n        if (trace > 0) {\n            S = Math.sqrt(trace + 1.0) * 2;\n            out[3] = 0.25 * S;\n            out[0] = (sm23 - sm32) / S;\n            out[1] = (sm31 - sm13) / S;\n            out[2] = (sm12 - sm21) / S;\n        } else if (sm11 > sm22 && sm11 > sm33) {\n            S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n            out[3] = (sm23 - sm32) / S;\n            out[0] = 0.25 * S;\n            out[1] = (sm12 + sm21) / S;\n            out[2] = (sm31 + sm13) / S;\n        } else if (sm22 > sm33) {\n            S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n            out[3] = (sm31 - sm13) / S;\n            out[0] = (sm12 + sm21) / S;\n            out[1] = 0.25 * S;\n            out[2] = (sm23 + sm32) / S;\n        } else {\n            S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n            out[3] = (sm12 - sm21) / S;\n            out[0] = (sm31 + sm13) / S;\n            out[1] = (sm23 + sm32) / S;\n            out[2] = 0.25 * S;\n        }\n\n        return out;\n    };\n})();\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Decompose a mat4 to TRS properties.\n *\n * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} srcMat Matrix element, to be decomposed to TRS properties.\n * @param {quat4} dstRotation Rotation element, to be overwritten.\n * @param {vec3} dstTranslation Translation element, to be overwritten.\n * @param {vec3} dstScale Scale element, to be overwritten\n */\nexport function decompose(srcMat, dstRotation, dstTranslation, dstScale) {\n    let sx = vec3.length([srcMat[0], srcMat[1], srcMat[2]]);\n    const sy = vec3.length([srcMat[4], srcMat[5], srcMat[6]]);\n    const sz = vec3.length([srcMat[8], srcMat[9], srcMat[10]]);\n\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n\n    getRotation(dstRotation, _m1);\n\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n}\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Compose TRS properties to a mat4.\n *\n * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} dstMat Matrix element, to be modified and returned.\n * @param {quat4} srcRotation Rotation element of matrix.\n * @param {vec3} srcTranslation Translation element of matrix.\n * @param {vec3} srcScale Scale element of matrix.\n * @returns {mat4} dstMat, overwritten to mat4 equivalent of given TRS properties.\n */\nexport function compose(dstMat, srcRotation, srcTranslation, srcScale) {\n    const te = dstMat;\n\n    const x = srcRotation[0],\n        y = srcRotation[1],\n        z = srcRotation[2],\n        w = srcRotation[3];\n    const x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    const xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    const yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    const wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    const sx = srcScale[0],\n        sy = srcScale[1],\n        sz = srcScale[2];\n\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n\n    return te;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspective(out, fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2);\n    let nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function ortho(out, left, right, bottom, top, near, far) {\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out, eye, target, up) {\n    let eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2];\n\n    let z0 = eyex - target[0],\n        z1 = eyey - target[1],\n        z2 = eyez - target[2];\n\n    let len = z0 * z0 + z1 * z1 + z2 * z2;\n    if (len === 0) {\n        // eye and target are in the same position\n        z2 = 1;\n    } else {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n\n    let x0 = upy * z2 - upz * z1,\n        x1 = upz * z0 - upx * z2,\n        x2 = upx * z1 - upy * z0;\n\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n    if (len === 0) {\n        // up and z are parallel\n        if (upz) {\n            upx += 1e-6;\n        } else if (upy) {\n            upz += 1e-6;\n        } else {\n            upy += 1e-6;\n        }\n        (x0 = upy * z2 - upz * z1), (x1 = upz * z0 - upx * z2), (x2 = upx * z1 - upy * z0);\n\n        len = x0 * x0 + x1 * x1 + x2 * x2;\n    }\n\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n\n    out[0] = x0;\n    out[1] = x1;\n    out[2] = x2;\n    out[3] = 0;\n    out[4] = z1 * x2 - z2 * x1;\n    out[5] = z2 * x0 - z0 * x2;\n    out[6] = z0 * x1 - z1 * x0;\n    out[7] = 0;\n    out[8] = z0;\n    out[9] = z1;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = eyex;\n    out[13] = eyey;\n    out[14] = eyez;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n}\n", "import * as Mat4Func from './functions/Mat4Func.js';\n\nexport class Mat4 extends Array {\n    constructor(\n        m00 = 1,\n        m01 = 0,\n        m02 = 0,\n        m03 = 0,\n        m10 = 0,\n        m11 = 1,\n        m12 = 0,\n        m13 = 0,\n        m20 = 0,\n        m21 = 0,\n        m22 = 1,\n        m23 = 0,\n        m30 = 0,\n        m31 = 0,\n        m32 = 0,\n        m33 = 1\n    ) {\n        super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    get x() {\n        return this[12];\n    }\n\n    get y() {\n        return this[13];\n    }\n\n    get z() {\n        return this[14];\n    }\n\n    get w() {\n        return this[15];\n    }\n\n    set x(v) {\n        this[12] = v;\n    }\n\n    set y(v) {\n        this[13] = v;\n    }\n\n    set z(v) {\n        this[14] = v;\n    }\n\n    set w(v) {\n        this[15] = v;\n    }\n\n    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        if (m00.length) return this.copy(m00);\n        Mat4Func.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat4Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, axis, m = this) {\n        Mat4Func.rotate(this, m, v, axis);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat4Func.scale(this, m, typeof v === 'number' ? [v, v, v] : v);\n        return this;\n    }\n\n    add(ma, mb) {\n        if (mb) Mat4Func.add(this, ma, mb);\n        else Mat4Func.add(this, this, ma);\n        return this;\n    }\n\n    sub(ma, mb) {\n        if (mb) Mat4Func.subtract(this, ma, mb);\n        else Mat4Func.subtract(this, this, ma);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (!ma.length) {\n            Mat4Func.multiplyScalar(this, this, ma);\n        } else if (mb) {\n            Mat4Func.multiply(this, ma, mb);\n        } else {\n            Mat4Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat4Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat4Func.copy(this, m);\n        return this;\n    }\n\n    fromPerspective({ fov, aspect, near, far } = {}) {\n        Mat4Func.perspective(this, fov, aspect, near, far);\n        return this;\n    }\n\n    fromOrthogonal({ left, right, bottom, top, near, far }) {\n        Mat4Func.ortho(this, left, right, bottom, top, near, far);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat4Func.fromQuat(this, q);\n        return this;\n    }\n\n    setPosition(v) {\n        this.x = v[0];\n        this.y = v[1];\n        this.z = v[2];\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat4Func.invert(this, m);\n        return this;\n    }\n\n    compose(q, pos, scale) {\n        Mat4Func.compose(this, q, pos, scale);\n        return this;\n    }\n\n    decompose(q, pos, scale) {\n        Mat4Func.decompose(this, q, pos, scale);\n        return this;\n    }\n\n    getRotation(q) {\n        Mat4Func.getRotation(q, this);\n        return this;\n    }\n\n    getTranslation(pos) {\n        Mat4Func.getTranslation(pos, this);\n        return this;\n    }\n\n    getScaling(scale) {\n        Mat4Func.getScaling(scale, this);\n        return this;\n    }\n\n    getMaxScaleOnAxis() {\n        return Mat4Func.getMaxScaleOnAxis(this);\n    }\n\n    lookAt(eye, target, up) {\n        Mat4Func.targetTo(this, eye, target, up);\n        return this;\n    }\n\n    determinant() {\n        return Mat4Func.determinant(this);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this[4] = a[o + 4];\n        this[5] = a[o + 5];\n        this[6] = a[o + 6];\n        this[7] = a[o + 7];\n        this[8] = a[o + 8];\n        this[9] = a[o + 9];\n        this[10] = a[o + 10];\n        this[11] = a[o + 11];\n        this[12] = a[o + 12];\n        this[13] = a[o + 13];\n        this[14] = a[o + 14];\n        this[15] = a[o + 15];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        a[o + 4] = this[4];\n        a[o + 5] = this[5];\n        a[o + 6] = this[6];\n        a[o + 7] = this[7];\n        a[o + 8] = this[8];\n        a[o + 9] = this[9];\n        a[o + 10] = this[10];\n        a[o + 11] = this[11];\n        a[o + 12] = this[12];\n        a[o + 13] = this[13];\n        a[o + 14] = this[14];\n        a[o + 15] = this[15];\n        return a;\n    }\n}\n", "// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nexport function fromRotationMatrix(out, m, order = 'YXZ') {\n    if (order === 'XYZ') {\n        out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n        if (Math.abs(m[8]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[2] = Math.atan2(-m[4], m[0]);\n        } else {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[2] = 0;\n        }\n    } else if (order === 'YXZ') {\n        out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n        if (Math.abs(m[9]) < 0.99999) {\n            out[1] = Math.atan2(m[8], m[10]);\n            out[2] = Math.atan2(m[1], m[5]);\n        } else {\n            out[1] = Math.atan2(-m[2], m[0]);\n            out[2] = 0;\n        }\n    } else if (order === 'ZXY') {\n        out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n        if (Math.abs(m[6]) < 0.99999) {\n            out[1] = Math.atan2(-m[2], m[10]);\n            out[2] = Math.atan2(-m[4], m[5]);\n        } else {\n            out[1] = 0;\n            out[2] = Math.atan2(m[1], m[0]);\n        }\n    } else if (order === 'ZYX') {\n        out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n        if (Math.abs(m[2]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[10]);\n            out[2] = Math.atan2(m[1], m[0]);\n        } else {\n            out[0] = 0;\n            out[2] = Math.atan2(-m[4], m[5]);\n        }\n    } else if (order === 'YZX') {\n        out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n        if (Math.abs(m[1]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[5]);\n            out[1] = Math.atan2(-m[2], m[0]);\n        } else {\n            out[0] = 0;\n            out[1] = Math.atan2(m[8], m[10]);\n        }\n    } else if (order === 'XZY') {\n        out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n        if (Math.abs(m[4]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[1] = Math.atan2(m[8], m[0]);\n        } else {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[1] = 0;\n        }\n    }\n\n    return out;\n}\n", "import * as EulerFunc from './functions/EulerFunc.js';\nimport { Mat4 } from './Mat4.js';\n\nconst tmpMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Euler extends Array {\n    constructor(x = 0, y = x, z = x, order = 'YXZ') {\n        super(x, y, z);\n        this.order = order;\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        this._target[0] = x;\n        this._target[1] = y;\n        this._target[2] = z;\n        this.onChange();\n        return this;\n    }\n\n    copy(v) {\n        this._target[0] = v[0];\n        this._target[1] = v[1];\n        this._target[2] = v[2];\n        this.onChange();\n        return this;\n    }\n\n    reorder(order) {\n        this._target.order = order;\n        this.onChange();\n        return this;\n    }\n\n    fromRotationMatrix(m, order = this.order) {\n        EulerFunc.fromRotationMatrix(this._target, m, order);\n        this.onChange();\n        return this;\n    }\n\n    fromQuaternion(q, order = this.order, isInternal) {\n        tmpMat4.fromQuaternion(q);\n        this._target.fromRotationMatrix(tmpMat4, order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Euler } from '../math/Euler.js';\n\nexport class Transform {\n    constructor() {\n        this.parent = null;\n        this.children = [];\n        this.visible = true;\n\n        this.matrix = new Mat4();\n        this.worldMatrix = new Mat4();\n        this.matrixAutoUpdate = true;\n        this.worldMatrixNeedsUpdate = false;\n\n        this.position = new Vec3();\n        this.quaternion = new Quat();\n        this.scale = new Vec3(1);\n        this.rotation = new Euler();\n        this.up = new Vec3(0, 1, 0);\n\n        this.rotation._target.onChange = () => this.quaternion.fromEuler(this.rotation, true);\n        this.quaternion._target.onChange = () => this.rotation.fromQuaternion(this.quaternion, undefined, true);\n    }\n\n    setParent(parent, notifyParent = true) {\n        if (this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n        this.parent = parent;\n        if (notifyParent && parent) parent.addChild(this, false);\n    }\n\n    addChild(child, notifyChild = true) {\n        if (!~this.children.indexOf(child)) this.children.push(child);\n        if (notifyChild) child.setParent(this, false);\n    }\n\n    removeChild(child, notifyChild = true) {\n        if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n        if (notifyChild) child.setParent(null, false);\n    }\n\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n        if (this.worldMatrixNeedsUpdate || force) {\n            if (this.parent === null) this.worldMatrix.copy(this.matrix);\n            else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n            this.worldMatrixNeedsUpdate = false;\n            force = true;\n        }\n\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].updateMatrixWorld(force);\n        }\n    }\n\n    updateMatrix() {\n        this.matrix.compose(this.quaternion, this.position, this.scale);\n        this.worldMatrixNeedsUpdate = true;\n    }\n\n    traverse(callback) {\n        // Return true in callback to stop traversing children\n        if (callback(this)) return;\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].traverse(callback);\n        }\n    }\n\n    decompose() {\n        this.matrix.decompose(this.quaternion._target, this.position, this.scale);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n\n    lookAt(target, invert = false) {\n        if (invert) this.matrix.lookAt(this.position, target, this.up);\n        else this.matrix.lookAt(target, this.position, this.up);\n        this.matrix.getRotation(this.quaternion._target);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\n\nexport class Camera extends Transform {\n    constructor(gl, { near = 0.1, far = 100, fov = 45, aspect = 1, left, right, bottom, top, zoom = 1 } = {}) {\n        super();\n\n        Object.assign(this, { near, far, fov, aspect, left, right, bottom, top, zoom });\n\n        this.projectionMatrix = new Mat4();\n        this.viewMatrix = new Mat4();\n        this.projectionViewMatrix = new Mat4();\n        this.worldPosition = new Vec3();\n\n        // Use orthographic if left/right set, else default to perspective camera\n        this.type = left || right ? 'orthographic' : 'perspective';\n\n        if (this.type === 'orthographic') this.orthographic();\n        else this.perspective();\n    }\n\n    perspective({ near = this.near, far = this.far, fov = this.fov, aspect = this.aspect } = {}) {\n        Object.assign(this, { near, far, fov, aspect });\n        this.projectionMatrix.fromPerspective({ fov: fov * (Math.PI / 180), aspect, near, far });\n        this.type = 'perspective';\n        return this;\n    }\n\n    orthographic({\n        near = this.near,\n        far = this.far,\n        left = this.left || -1,\n        right = this.right || 1,\n        bottom = this.bottom || -1,\n        top = this.top || 1,\n        zoom = this.zoom,\n    } = {}) {\n        Object.assign(this, { near, far, left, right, bottom, top, zoom });\n        left /= zoom;\n        right /= zoom;\n        bottom /= zoom;\n        top /= zoom;\n        this.projectionMatrix.fromOrthogonal({ left, right, bottom, top, near, far });\n        this.type = 'orthographic';\n        return this;\n    }\n\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n        this.viewMatrix.inverse(this.worldMatrix);\n        this.worldMatrix.getTranslation(this.worldPosition);\n\n        // used for sorting\n        this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n        return this;\n    }\n\n    updateProjectionMatrix() {\n        if (this.type === 'perspective') {\n            return this.perspective();\n        } else {\n            return this.orthographic();\n        }\n    }\n\n    lookAt(target) {\n        super.lookAt(target, true);\n        return this;\n    }\n\n    // Project 3D coordinate to 2D point\n    project(v) {\n        v.applyMatrix4(this.viewMatrix);\n        v.applyMatrix4(this.projectionMatrix);\n        return this;\n    }\n\n    // Unproject 2D point to 3D coordinate\n    unproject(v) {\n        v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n        v.applyMatrix4(this.worldMatrix);\n        return this;\n    }\n\n    updateFrustum() {\n        if (!this.frustum) {\n            this.frustum = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n        }\n\n        const m = this.projectionViewMatrix;\n        this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n        this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n        this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n        this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n        this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n        this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n        for (let i = 0; i < 6; i++) {\n            const invLen = 1.0 / this.frustum[i].distance();\n            this.frustum[i].multiply(invLen);\n            this.frustum[i].constant *= invLen;\n        }\n    }\n\n    frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {\n        // If no position attribute, treat as frustumCulled false\n        if (!node.geometry.attributes.position) return true;\n\n        if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n\n        if (!node.geometry.bounds) return true;\n\n        const center = tempVec3a;\n        center.copy(node.geometry.bounds.center);\n        center.applyMatrix4(worldMatrix);\n\n        const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();\n\n        return this.frustumIntersectsSphere(center, radius);\n    }\n\n    frustumIntersectsSphere(center, radius) {\n        const normal = tempVec3b;\n\n        for (let i = 0; i < 6; i++) {\n            const plane = this.frustum[i];\n            const distance = normal.copy(plane).dot(center) + plane.constant;\n            if (distance < -radius) return false;\n        }\n        return true;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n\n    // Calculate the determinant\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b00 = b[0],\n        b01 = b[1],\n        b02 = b[2];\n    let b10 = b[3],\n        b11 = b[4],\n        b12 = b[5];\n    let b20 = b[6],\n        b21 = b[7],\n        b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        x = v[0],\n        y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n}\n", "import * as Mat3Func from './functions/Mat3Func.js';\n\nexport class Mat3 extends Array {\n    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n        super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        if (m00.length) return this.copy(m00);\n        Mat3Func.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat3Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, m = this) {\n        Mat3Func.rotate(this, m, v);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat3Func.scale(this, m, v);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (mb) {\n            Mat3Func.multiply(this, ma, mb);\n        } else {\n            Mat3Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat3Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat3Func.copy(this, m);\n        return this;\n    }\n\n    fromMatrix4(m) {\n        Mat3Func.fromMat4(this, m);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat3Func.fromQuat(this, q);\n        return this;\n    }\n\n    fromBasis(vec3a, vec3b, vec3c) {\n        this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat3Func.invert(this, m);\n        return this;\n    }\n\n    getNormalMatrix(m) {\n        Mat3Func.normalFromMat4(this, m);\n        return this;\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nlet ID = 0;\n\nexport class Mesh extends Transform {\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}) {\n        super();\n        if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n\n    draw({ camera } = {}) {\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: { value: null },\n                    viewMatrix: { value: null },\n                    modelViewMatrix: { value: null },\n                    normalMatrix: { value: null },\n                    projectionMatrix: { value: null },\n                    cameraPosition: { value: null },\n                });\n            }\n\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({ flipFaces });\n        this.geometry.draw({ mode: this.mode, program: this.program });\n        this.afterRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n    }\n}\n", "// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n", "import { Texture } from './Texture.js'\n\nexport class RenderTarget {\n    constructor(\n        gl,\n        {\n            width = gl.canvas.width,\n            height = gl.canvas.height,\n            target = gl.FRAMEBUFFER,\n            color = 1, // number of color attachments\n            depth = true,\n            stencil = false,\n            depthTexture = false,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = minFilter,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            unpackAlignment,\n            premultiplyAlpha,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.buffer = this.gl.createFramebuffer();\n        this.target = target;\n        this.gl.renderer.bindFramebuffer(this);\n\n        this.textures = [];\n        const drawBuffers = [];\n\n        // create and attach required num of color textures\n        for (let i = 0; i < color; i++) {\n            this.textures.push(\n                new Texture(gl, {\n                    width,\n                    height,\n                    wrapS,\n                    wrapT,\n                    wrapR,\n                    minFilter,\n                    magFilter,\n                    type,\n                    format,\n                    internalFormat,\n                    unpackAlignment,\n                    premultiplyAlpha,\n                    flipY: false,\n                    generateMipmaps: false,\n                })\n            );\n            this.textures[i].update();\n            this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0 /* level */);\n            drawBuffers.push(this.gl.COLOR_ATTACHMENT0 + i);\n        }\n\n        // For multi-render targets shader access\n        if (drawBuffers.length > 1) this.gl.renderer.drawBuffers(drawBuffers);\n\n        // alias for majority of use cases\n        this.texture = this.textures[0];\n\n        // note depth textures break stencil - so can't use together\n        if (depthTexture && (this.gl.renderer.isWebgl2 || this.gl.renderer.getExtension('WEBGL_depth_texture'))) {\n            this.depthTexture = new Texture(gl, {\n                width,\n                height,\n                minFilter: this.gl.NEAREST,\n                magFilter: this.gl.NEAREST,\n                format: this.stencil ? this.gl.DEPTH_STENCIL : this.gl.DEPTH_COMPONENT,\n                internalFormat: gl.renderer.isWebgl2 ? (this.stencil ? this.gl.DEPTH24_STENCIL8 : this.gl.DEPTH_COMPONENT16) : this.gl.DEPTH_COMPONENT,\n                type: this.stencil ? this.gl.UNSIGNED_INT_24_8 : this.gl.UNSIGNED_INT,\n            });\n            this.depthTexture.update();\n            this.gl.framebufferTexture2D(this.target, this.stencil ? this.gl.DEPTH_STENCIL_ATTACHMENT : this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0 /* level */);\n        } else {\n            // Render buffers\n            if (depth && !stencil) {\n                this.depthBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer);\n            }\n\n            if (stencil && !depth) {\n                this.stencilBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer);\n            }\n\n            if (depth && stencil) {\n                this.depthStencilBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer);\n            }\n        }\n\n        this.gl.renderer.bindFramebuffer({ target: this.target });\n    }\n\n    setSize(width, height) {\n        if (this.width === width && this.height === height) return;\n\n        this.width = width;\n        this.height = height;\n        this.gl.renderer.bindFramebuffer(this);\n\n        for (let i = 0; i < this.textures.length; i++) {\n            this.textures[i].width = width;\n            this.textures[i].height = height;\n            this.textures[i].needsUpdate = true;\n            this.textures[i].update();\n            this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0 /* level */);\n        }\n\n        if (this.depthTexture) {\n            this.depthTexture.width = width;\n            this.depthTexture.height = height;\n            this.depthTexture.needsUpdate = true;\n            this.depthTexture.update();\n            this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0 /* level */);\n        } else {\n            if (this.depthBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n            }\n\n            if (this.stencilBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n            }\n\n            if (this.depthStencilBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n            }\n        }\n\n        this.gl.renderer.bindFramebuffer({ target: this.target });\n    }\n}\n", "const NAMES = {\n    black: '#000000',\n    white: '#ffffff',\n    red: '#ff0000',\n    green: '#00ff00',\n    blue: '#0000ff',\n    fuchsia: '#ff00ff',\n    cyan: '#00ffff',\n    yellow: '#ffff00',\n    orange: '#ff8000',\n};\n\nexport function hexToRGB(hex) {\n    if (hex.length === 4) hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n    const rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!rgb) console.warn(`Unable to convert hex string ${hex} to rgb values`);\n    return [parseInt(rgb[1], 16) / 255, parseInt(rgb[2], 16) / 255, parseInt(rgb[3], 16) / 255];\n}\n\nexport function numberToRGB(num) {\n    num = parseInt(num);\n    return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\n}\n\nexport function parseColor(color) {\n    // Empty\n    if (color === undefined) return [0, 0, 0];\n\n    // Decimal\n    if (arguments.length === 3) return arguments;\n\n    // Number\n    if (!isNaN(color)) return numberToRGB(color);\n\n    // Hex\n    if (color[0] === '#') return hexToRGB(color);\n\n    // Names\n    if (NAMES[color.toLowerCase()]) return hexToRGB(NAMES[color.toLowerCase()]);\n\n    console.warn('Color format not recognised');\n    return [0, 0, 0];\n}\n", "import * as ColorFunc from './functions/ColorFunc.js';\n\n// Color stored as an array of RGB decimal values (between 0 > 1)\n// Constructor and set method accept following formats:\n// new Color() - Empty (defaults to black)\n// new Color([0.2, 0.4, 1.0]) - Decimal Array (or another Color instance)\n// new Color(0.7, 0.0, 0.1) - Decimal RGB values\n// new Color('#ff0000') - Hex string\n// new Color('#ccc') - Short-hand Hex string\n// new Color(0x4f27e8) - Number\n// new Color('red') - Color name string (short list in ColorFunc.js)\n\nexport class Color extends Array {\n    constructor(color) {\n        if (Array.isArray(color)) return super(...color);\n        return super(...ColorFunc.parseColor(...arguments));\n    }\n\n    get r() {\n        return this[0];\n    }\n\n    get g() {\n        return this[1];\n    }\n\n    get b() {\n        return this[2];\n    }\n\n    set r(v) {\n        this[0] = v;\n    }\n\n    set g(v) {\n        this[1] = v;\n    }\n\n    set b(v) {\n        this[2] = v;\n    }\n\n    set(color) {\n        if (Array.isArray(color)) return this.copy(color);\n        return this.copy(ColorFunc.parseColor(...arguments));\n    }\n\n    copy(v) {\n        this[0] = v[0];\n        this[1] = v[1];\n        this[2] = v[2];\n        return this;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    var x = a[0],\n        y = a[1];\n    return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x * x + y * y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\nexport function cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec2} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0];\n    let y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n", "import * as Vec2Func from './functions/Vec2Func.js';\n\nexport class Vec2 extends Array {\n    constructor(x = 0, y = x) {\n        super(x, y);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set(x, y = x) {\n        if (x.length) return this.copy(x);\n        Vec2Func.set(this, x, y);\n        return this;\n    }\n\n    copy(v) {\n        Vec2Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec2Func.add(this, va, vb);\n        else Vec2Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec2Func.subtract(this, va, vb);\n        else Vec2Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec2Func.multiply(this, this, v);\n        else Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec2Func.divide(this, this, v);\n        else Vec2Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec2Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec2Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec2Func.distance(this, v);\n        else return Vec2Func.length(this);\n    }\n\n    squaredLen() {\n        return this.squaredDistance();\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec2Func.squaredDistance(this, v);\n        else return Vec2Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec2Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) return Vec2Func.cross(va, vb);\n        return Vec2Func.cross(this, va);\n    }\n\n    scale(v) {\n        Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec2Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec2Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec2Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec2Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec2Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    lerp(v, a) {\n        Vec2Func.lerp(this, this, v, a);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec2Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec2(this[0], this[1]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        return a;\n    }\n}\n", "import * as Vec4Func from './functions/Vec4Func.js';\n\nexport class Vec4 extends Array {\n    constructor(x = 0, y = x, z = x, w = x) {\n        super(x, y, z, w);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set w(v) {\n        this[3] = v;\n    }\n\n    set(x, y = x, z = x, w = x) {\n        if (x.length) return this.copy(x);\n        Vec4Func.set(this, x, y, z, w);\n        return this;\n    }\n\n    copy(v) {\n        Vec4Func.copy(this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec4Func.normalize(this, this);\n        return this;\n    }\n\n    multiply(v) {\n        Vec4Func.scale(this, this, v);\n        return this;\n    }\n\n    dot(v) {\n        return Vec4Func.dot(this, v);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\n\nexport class Plane extends Geometry {\n    constructor(gl, { width = 1, height = 1, widthSegments = 1, heightSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n\n        // Determine length of arrays\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        // Generate empty arrays once\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = numIndices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        Plane.buildPlane(position, normal, uv, index, width, height, 0, wSegs, hSegs);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n\n    static buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {\n        const io = i;\n        const segW = width / wSegs;\n        const segH = height / hSegs;\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let y = iy * segH - height / 2;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let x = ix * segW - width / 2;\n\n                position[i * 3 + u] = x * uDir;\n                position[i * 3 + v] = y * vDir;\n                position[i * 3 + w] = depth / 2;\n\n                normal[i * 3 + u] = 0;\n                normal[i * 3 + v] = 0;\n                normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n\n                uv[i * 2] = ix / wSegs;\n                uv[i * 2 + 1] = 1 - iy / hSegs;\n\n                if (iy === hSegs || ix === wSegs) continue;\n                let a = io + ix + iy * (wSegs + 1);\n                let b = io + ix + (iy + 1) * (wSegs + 1);\n                let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n                let d = io + ix + iy * (wSegs + 1) + 1;\n\n                index[ii * 6] = a;\n                index[ii * 6 + 1] = b;\n                index[ii * 6 + 2] = d;\n                index[ii * 6 + 3] = b;\n                index[ii * 6 + 4] = c;\n                index[ii * 6 + 5] = d;\n                ii++;\n            }\n        }\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Plane } from './Plane.js';\n\nexport class Box extends Geometry {\n    constructor(gl, { width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const dSegs = depthSegments;\n\n        const num = (wSegs + 1) * (hSegs + 1) * 2 + (wSegs + 1) * (dSegs + 1) * 2 + (hSegs + 1) * (dSegs + 1) * 2;\n        const numIndices = (wSegs * hSegs * 2 + wSegs * dSegs * 2 + hSegs * dSegs * 2) * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n\n        // left, right\n        Plane.buildPlane(position, normal, uv, index, depth, height, width, dSegs, hSegs, 2, 1, 0, -1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, depth, height, -width, dSegs, hSegs, 2, 1, 0, 1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        // top, bottom\n        Plane.buildPlane(position, normal, uv, index, width, depth, height, dSegs, wSegs, 0, 2, 1, 1, 1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, depth, -height, dSegs, wSegs, 0, 2, 1, 1, -1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        // front, back\n        Plane.buildPlane(position, normal, uv, index, width, height, -depth, wSegs, hSegs, 0, 1, 2, -1, -1, i, ii);\n        i += (wSegs + 1) * (hSegs + 1);\n        ii += wSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, 0, 1, 2, 1, -1, i, ii);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Sphere extends Geometry {\n    constructor(\n        gl,\n        {\n            radius = 0.5,\n            widthSegments = 16,\n            heightSegments = Math.ceil(widthSegments * 0.5),\n            phiStart = 0,\n            phiLength = Math.PI * 2,\n            thetaStart = 0,\n            thetaLength = Math.PI,\n            attributes = {},\n        } = {}\n    ) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const pStart = phiStart;\n        const pLength = phiLength;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let iv = 0;\n        let ii = 0;\n        let te = tStart + tLength;\n        const grid = [];\n\n        let n = new Vec3();\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let vRow = [];\n            let v = iy / hSegs;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let u = ix / wSegs;\n                let x = -radius * Math.cos(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n                let y = radius * Math.cos(tStart + v * tLength);\n                let z = radius * Math.sin(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n\n                position[i * 3] = x;\n                position[i * 3 + 1] = y;\n                position[i * 3 + 2] = z;\n\n                n.set(x, y, z).normalize();\n                normal[i * 3] = n.x;\n                normal[i * 3 + 1] = n.y;\n                normal[i * 3 + 2] = n.z;\n\n                uv[i * 2] = u;\n                uv[i * 2 + 1] = 1 - v;\n\n                vRow.push(iv++);\n            }\n\n            grid.push(vRow);\n        }\n\n        for (let iy = 0; iy < hSegs; iy++) {\n            for (let ix = 0; ix < wSegs; ix++) {\n                let a = grid[iy][ix + 1];\n                let b = grid[iy][ix];\n                let c = grid[iy + 1][ix];\n                let d = grid[iy + 1][ix + 1];\n\n                if (iy !== 0 || tStart > 0) {\n                    index[ii * 3] = a;\n                    index[ii * 3 + 1] = b;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n                if (iy !== hSegs - 1 || te < Math.PI) {\n                    index[ii * 3] = b;\n                    index[ii * 3 + 1] = c;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Cylinder extends Geometry {\n    constructor(\n        gl,\n        {\n            radiusTop = 0.5,\n            radiusBottom = 0.5,\n            height = 1,\n            radialSegments = 8,\n            heightSegments = 1,\n            openEnded = false,\n            thetaStart = 0,\n            thetaLength = Math.PI * 2,\n            attributes = {},\n        } = {}\n    ) {\n        const rSegs = radialSegments;\n        const hSegs = heightSegments;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n        const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n        const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n        const indexArray = [];\n\n        addHeight();\n        if (!openEnded) {\n            if (radiusTop) addCap(true);\n            if (radiusBottom) addCap(false);\n        }\n\n        function addHeight() {\n            let x, y;\n            const n = new Vec3();\n            const slope = (radiusBottom - radiusTop) / height;\n\n            for (y = 0; y <= hSegs; y++) {\n                const indexRow = [];\n                const v = y / hSegs;\n\n                const r = v * (radiusBottom - radiusTop) + radiusTop;\n                for (x = 0; x <= rSegs; x++) {\n                    const u = x / rSegs;\n                    const theta = u * tLength + tStart;\n                    const sinTheta = Math.sin(theta);\n                    const cosTheta = Math.cos(theta);\n\n                    position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n                    n.set(sinTheta, slope, cosTheta).normalize();\n                    normal.set([n.x, n.y, n.z], i * 3);\n                    uv.set([u, 1 - v], i * 2);\n                    indexRow.push(i++);\n                }\n                indexArray.push(indexRow);\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                for (y = 0; y < hSegs; y++) {\n                    const a = indexArray[y][x];\n                    const b = indexArray[y + 1][x];\n                    const c = indexArray[y + 1][x + 1];\n                    const d = indexArray[y][x + 1];\n\n                    index.set([a, b, d, b, c, d], ii * 3);\n                    ii += 2;\n                }\n            }\n        }\n\n        function addCap(isTop) {\n            let x;\n            const r = isTop === true ? radiusTop : radiusBottom;\n            const sign = isTop === true ? 1 : -1;\n\n            const centerIndex = i;\n            position.set([0, 0.5 * height * sign, 0], i * 3);\n            normal.set([0, sign, 0], i * 3);\n            uv.set([0.5, 0.5], i * 2);\n            i++;\n\n            for (x = 0; x <= rSegs; x++) {\n                const u = x / rSegs;\n                const theta = u * tLength + tStart;\n                const cosTheta = Math.cos(theta);\n                const sinTheta = Math.sin(theta);\n\n                position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n                normal.set([0, sign, 0], i * 3);\n                uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n                i++;\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                const j = centerIndex + x + 1;\n                if (isTop) {\n                    index.set([j, j + 1, centerIndex], ii * 3);\n                } else {\n                    index.set([j + 1, j, centerIndex], ii * 3);\n                }\n                ii++;\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\n\nexport class Triangle extends Geometry {\n    constructor(gl, { attributes = {} } = {}) {\n        Object.assign(attributes, {\n            position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },\n            uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "// https://github.com/mrdoob/three.js/blob/master/src/geometries/TorusGeometry.js\n\nimport { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Torus extends Geometry {\n    constructor(gl, { radius = 0.5, tube = 0.2, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2, attributes = {} } = {}) {\n        const num = (radialSegments + 1) * (tubularSegments + 1);\n        const numIndices = radialSegments * tubularSegments * 6;\n\n        const vertices = new Float32Array(num * 3);\n        const normals = new Float32Array(num * 3);\n        const uvs = new Float32Array(num * 2);\n        const indices = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        const center = new Vec3();\n        const vertex = new Vec3();\n        const normal = new Vec3();\n\n        // generate vertices, normals and uvs\n        let idx = 0;\n        for (let j = 0; j <= radialSegments; j++) {\n            for (let i = 0; i <= tubularSegments; i++, idx++) {\n                const u = (i / tubularSegments) * arc;\n                const v = (j / radialSegments) * Math.PI * 2;\n\n                // vertex\n                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n                vertex.z = tube * Math.sin(v);\n\n                vertices.set([vertex.x, vertex.y, vertex.z], idx * 3);\n\n                // normal\n                center.x = radius * Math.cos(u);\n                center.y = radius * Math.sin(u);\n                normal.sub(vertex, center).normalize();\n\n                normals.set([normal.x, normal.y, normal.z], idx * 3);\n\n                // uv\n                uvs.set([i / tubularSegments, j / radialSegments], idx * 2);\n            }\n        }\n\n        // generate indices\n        idx = 0;\n        for (let j = 1; j <= radialSegments; j++) {\n            for (let i = 1; i <= tubularSegments; i++, idx++) {\n                // indices\n                const a = (tubularSegments + 1) * j + i - 1;\n                const b = (tubularSegments + 1) * (j - 1) + i - 1;\n                const c = (tubularSegments + 1) * (j - 1) + i;\n                const d = (tubularSegments + 1) * j + i;\n\n                // faces\n                indices.set([a, b, d, b, c, d], idx * 6);\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: vertices },\n            normal: { size: 3, data: normals },\n            uv: { size: 2, data: uvs },\n            index: { data: indices },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\n// TODO: abstract event handlers so can be fed from other sources\n// TODO: make scroll zoom more accurate than just >/< zero\n// TODO: be able to pass in new camera position\n\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\nconst STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, DOLLY_PAN: 3 };\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\n\nexport function Orbit(\n    object,\n    {\n        element = document,\n        enabled = true,\n        target = new Vec3(),\n        ease = 0.25,\n        inertia = 0.85,\n        enableRotate = true,\n        rotateSpeed = 0.1,\n        autoRotate = false,\n        autoRotateSpeed = 1.0,\n        enableZoom = true,\n        zoomSpeed = 1,\n        zoomStyle = 'dolly',\n        enablePan = true,\n        panSpeed = 0.1,\n        minPolarAngle = 0,\n        maxPolarAngle = Math.PI,\n        minAzimuthAngle = -Infinity,\n        maxAzimuthAngle = Infinity,\n        minDistance = 0,\n        maxDistance = Infinity,\n    } = {}\n) {\n    this.enabled = enabled;\n    this.target = target;\n    this.zoomStyle = zoomStyle;\n\n    // Catch attempts to disable - set to 1 so has no effect\n    ease = ease || 1;\n    inertia = inertia || 0;\n\n    this.minDistance = minDistance;\n    this.maxDistance = maxDistance;\n\n    // current position in sphericalTarget coordinates\n    const sphericalDelta = { radius: 1, phi: 0, theta: 0 };\n    const sphericalTarget = { radius: 1, phi: 0, theta: 0 };\n    const spherical = { radius: 1, phi: 0, theta: 0 };\n    const panDelta = new Vec3();\n\n    // Grab initial position values\n    const offset = new Vec3();\n    offset.copy(object.position).sub(this.target);\n    spherical.radius = sphericalTarget.radius = offset.distance();\n    spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n    spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n\n    this.offset = offset;\n\n    this.update = () => {\n        if (autoRotate) {\n            handleAutoRotate();\n        }\n\n        // apply delta\n        sphericalTarget.radius *= sphericalDelta.radius;\n        sphericalTarget.theta += sphericalDelta.theta;\n        sphericalTarget.phi += sphericalDelta.phi;\n\n        // apply boundaries\n        sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n        sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n        sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius));\n\n        // ease values\n        spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n        spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n        spherical.radius += (sphericalTarget.radius - spherical.radius) * ease;\n\n        // apply pan to target. As offset is relative to target, it also shifts\n        this.target.add(panDelta);\n\n        // apply rotation to offset\n        let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n        offset.x = sinPhiRadius * Math.sin(spherical.theta);\n        offset.y = spherical.radius * Math.cos(spherical.phi);\n        offset.z = sinPhiRadius * Math.cos(spherical.theta);\n\n        // Apply updated values to object\n        object.position.copy(this.target).add(offset);\n        object.lookAt(this.target);\n\n        // Apply inertia to values\n        sphericalDelta.theta *= inertia;\n        sphericalDelta.phi *= inertia;\n        panDelta.multiply(inertia);\n\n        // Reset scale every frame to avoid applying scale multiple times\n        sphericalDelta.radius = 1;\n    };\n\n    // Updates internals with new position\n    this.forcePosition = () => {\n        offset.copy(object.position).sub(this.target);\n        spherical.radius = sphericalTarget.radius = offset.distance();\n        spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n        spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n        object.lookAt(this.target);\n    };\n\n    // Everything below here just updates panDelta and sphericalDelta\n    // Using those two objects' values, the orbit is calculated\n\n    const rotateStart = new Vec2();\n    const panStart = new Vec2();\n    const dollyStart = new Vec2();\n\n    let state = STATE.NONE;\n    this.mouseButtons = { ORBIT: 0, ZOOM: 1, PAN: 2 };\n\n    function getZoomScale() {\n        return Math.pow(0.95, zoomSpeed);\n    }\n\n    function panLeft(distance, m) {\n        tempVec3.set(m[0], m[1], m[2]);\n        tempVec3.multiply(-distance);\n        panDelta.add(tempVec3);\n    }\n\n    function panUp(distance, m) {\n        tempVec3.set(m[4], m[5], m[6]);\n        tempVec3.multiply(distance);\n        panDelta.add(tempVec3);\n    }\n\n    const pan = (deltaX, deltaY) => {\n        let el = element === document ? document.body : element;\n        tempVec3.copy(object.position).sub(this.target);\n        let targetDistance = tempVec3.distance();\n        targetDistance *= Math.tan((((object.fov || 45) / 2) * Math.PI) / 180.0);\n        panLeft((2 * deltaX * targetDistance) / el.clientHeight, object.matrix);\n        panUp((2 * deltaY * targetDistance) / el.clientHeight, object.matrix);\n    };\n\n    const dolly = (dollyScale) => {\n        if (this.zoomStyle === 'dolly') sphericalDelta.radius /= dollyScale;\n        else {\n            object.fov /= dollyScale;\n            if (object.type === 'orthographic') object.orthographic();\n            else object.perspective();\n        }\n    };\n\n    function handleAutoRotate() {\n        const angle = ((2 * Math.PI) / 60 / 60) * autoRotateSpeed;\n        sphericalDelta.theta -= angle;\n    }\n\n    function handleMoveRotate(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed);\n        let el = element === document ? document.body : element;\n        sphericalDelta.theta -= (2 * Math.PI * tempVec2b.x) / el.clientHeight;\n        sphericalDelta.phi -= (2 * Math.PI * tempVec2b.y) / el.clientHeight;\n        rotateStart.copy(tempVec2a);\n    }\n\n    function handleMouseMoveDolly(e) {\n        tempVec2a.set(e.clientX, e.clientY);\n        tempVec2b.sub(tempVec2a, dollyStart);\n        if (tempVec2b.y > 0) {\n            dolly(getZoomScale());\n        } else if (tempVec2b.y < 0) {\n            dolly(1 / getZoomScale());\n        }\n        dollyStart.copy(tempVec2a);\n    }\n\n    function handleMovePan(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n        pan(tempVec2b.x, tempVec2b.y);\n        panStart.copy(tempVec2a);\n    }\n\n    function handleTouchStartDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            panStart.set(x, y);\n        }\n    }\n\n    function handleTouchMoveDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            tempVec2a.set(0, distance);\n            tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n            dolly(tempVec2b.y);\n            dollyStart.copy(tempVec2a);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            handleMovePan(x, y);\n        }\n    }\n\n    const onMouseDown = (e) => {\n        if (!this.enabled) return;\n\n        switch (e.button) {\n            case this.mouseButtons.ORBIT:\n                if (enableRotate === false) return;\n                rotateStart.set(e.clientX, e.clientY);\n                state = STATE.ROTATE;\n                break;\n            case this.mouseButtons.ZOOM:\n                if (enableZoom === false) return;\n                dollyStart.set(e.clientX, e.clientY);\n                state = STATE.DOLLY;\n                break;\n            case this.mouseButtons.PAN:\n                if (enablePan === false) return;\n                panStart.set(e.clientX, e.clientY);\n                state = STATE.PAN;\n                break;\n        }\n\n        if (state !== STATE.NONE) {\n            window.addEventListener('mousemove', onMouseMove, false);\n            window.addEventListener('mouseup', onMouseUp, false);\n        }\n    };\n\n    const onMouseMove = (e) => {\n        if (!this.enabled) return;\n\n        switch (state) {\n            case STATE.ROTATE:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.clientX, e.clientY);\n                break;\n            case STATE.DOLLY:\n                if (enableZoom === false) return;\n                handleMouseMoveDolly(e);\n                break;\n            case STATE.PAN:\n                if (enablePan === false) return;\n                handleMovePan(e.clientX, e.clientY);\n                break;\n        }\n    };\n\n    const onMouseUp = () => {\n        window.removeEventListener('mousemove', onMouseMove, false);\n        window.removeEventListener('mouseup', onMouseUp, false);\n        state = STATE.NONE;\n    };\n\n    const onMouseWheel = (e) => {\n        if (!this.enabled || !enableZoom || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n        e.stopPropagation();\n        e.preventDefault();\n\n        if (e.deltaY < 0) {\n            dolly(1 / getZoomScale());\n        } else if (e.deltaY > 0) {\n            dolly(getZoomScale());\n        }\n    };\n\n    const onTouchStart = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n                state = STATE.ROTATE;\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchStartDollyPan(e);\n                state = STATE.DOLLY_PAN;\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchMove = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchMoveDollyPan(e);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchEnd = () => {\n        if (!this.enabled) return;\n        state = STATE.NONE;\n    };\n\n    const onContextMenu = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n    };\n\n    function addHandlers() {\n        element.addEventListener('contextmenu', onContextMenu, false);\n        element.addEventListener('mousedown', onMouseDown, false);\n        element.addEventListener('wheel', onMouseWheel, { passive: false });\n        element.addEventListener('touchstart', onTouchStart, { passive: false });\n        element.addEventListener('touchend', onTouchEnd, false);\n        element.addEventListener('touchmove', onTouchMove, { passive: false });\n    }\n\n    this.remove = function () {\n        element.removeEventListener('contextmenu', onContextMenu);\n        element.removeEventListener('mousedown', onMouseDown);\n        element.removeEventListener('wheel', onMouseWheel);\n        element.removeEventListener('touchstart', onTouchStart);\n        element.removeEventListener('touchend', onTouchEnd);\n        element.removeEventListener('touchmove', onTouchMove);\n        window.removeEventListener('mousemove', onMouseMove);\n        window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    addHandlers();\n}\n", "// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\nconst tempVec2c = /* @__PURE__ */ new Vec2();\n\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\nconst tempVec3c = /* @__PURE__ */ new Vec3();\nconst tempVec3d = /* @__PURE__ */ new Vec3();\nconst tempVec3e = /* @__PURE__ */ new Vec3();\nconst tempVec3f = /* @__PURE__ */ new Vec3();\nconst tempVec3g = /* @__PURE__ */ new Vec3();\nconst tempVec3h = /* @__PURE__ */ new Vec3();\nconst tempVec3i = /* @__PURE__ */ new Vec3();\nconst tempVec3j = /* @__PURE__ */ new Vec3();\nconst tempVec3k = /* @__PURE__ */ new Vec3();\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Raycast {\n    constructor() {\n        this.origin = new Vec3();\n        this.direction = new Vec3();\n    }\n\n    // Set ray from mouse unprojection\n    castMouse(camera, mouse = [0, 0]) {\n        if (camera.type === 'orthographic') {\n            // Set origin\n            // Since camera is orthographic, origin is not the camera position\n            const { left, right, bottom, top, zoom } = camera;\n            const x = left / zoom + ((right - left) / zoom) * (mouse[0] * 0.5 + 0.5);\n            const y = bottom / zoom + ((top - bottom) / zoom) * (mouse[1] * 0.5 + 0.5);\n            this.origin.set(x, y, 0);\n            this.origin.applyMatrix4(camera.worldMatrix);\n\n            // Set direction\n            // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n            this.direction.x = -camera.worldMatrix[8];\n            this.direction.y = -camera.worldMatrix[9];\n            this.direction.z = -camera.worldMatrix[10];\n        } else {\n            // Set origin\n            camera.worldMatrix.getTranslation(this.origin);\n\n            // Set direction\n            this.direction.set(mouse[0], mouse[1], 0.5);\n            camera.unproject(this.direction);\n            this.direction.sub(this.origin).normalize();\n        }\n    }\n\n    intersectBounds(meshes, { maxDistance, output = [] } = {}) {\n        if (!Array.isArray(meshes)) meshes = [meshes];\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n\n        const hits = output;\n        hits.length = 0;\n\n        meshes.forEach((mesh) => {\n            // Create bounds\n            if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n            const bounds = mesh.geometry.bounds;\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            // Break out early if bounds too far away from origin\n            if (maxDistance) {\n                if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n            }\n\n            let localDistance = 0;\n\n            // Check origin isn't inside bounds before testing intersection\n            if (mesh.geometry.raycast === 'sphere') {\n                if (origin.distance(bounds.center) > bounds.radius) {\n                    localDistance = this.intersectSphere(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            } else {\n                if (\n                    origin.x < bounds.min.x ||\n                    origin.x > bounds.max.x ||\n                    origin.y < bounds.min.y ||\n                    origin.y > bounds.max.y ||\n                    origin.z < bounds.min.z ||\n                    origin.z > bounds.max.z\n                ) {\n                    localDistance = this.intersectBox(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            }\n\n            if (maxDistance && localDistance > localMaxDistance) return;\n\n            // Create object on mesh to avoid generating lots of objects\n            if (!mesh.hit) mesh.hit = { localPoint: new Vec3(), point: new Vec3() };\n\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            hits.push(mesh);\n        });\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectMeshes(meshes, { cullFace = true, maxDistance, includeUV = true, includeNormal = true, output = [] } = {}) {\n        // Test bounds first before testing geometry\n        const hits = this.intersectBounds(meshes, { maxDistance, output });\n        if (!hits.length) return hits;\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n        const a = tempVec3c;\n        const b = tempVec3d;\n        const c = tempVec3e;\n        const closestFaceNormal = tempVec3f;\n        const faceNormal = tempVec3g;\n        const barycoord = tempVec3h;\n        const uvA = tempVec2a;\n        const uvB = tempVec2b;\n        const uvC = tempVec2c;\n\n        for (let i = hits.length - 1; i >= 0; i--) {\n            const mesh = hits[i];\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            let localDistance = 0;\n            let closestA, closestB, closestC;\n\n            const geometry = mesh.geometry;\n            const attributes = geometry.attributes;\n            const index = attributes.index;\n            const position = attributes.position;\n\n            const start = Math.max(0, geometry.drawRange.start);\n            const end = Math.min(index ? index.count : position.count, geometry.drawRange.start + geometry.drawRange.count);\n            // Data loaded shouldn't haave stride, only buffers\n            // const stride = position.stride ? position.stride / position.data.BYTES_PER_ELEMENT : position.size;\n            const stride = position.size;\n\n            for (let j = start; j < end; j += 3) {\n                // Position attribute indices for each triangle\n                const ai = index ? index.data[j] : j;\n                const bi = index ? index.data[j + 1] : j + 1;\n                const ci = index ? index.data[j + 2] : j + 2;\n\n                a.fromArray(position.data, ai * stride);\n                b.fromArray(position.data, bi * stride);\n                c.fromArray(position.data, ci * stride);\n\n                const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n                if (!distance) continue;\n\n                // Too far away\n                if (maxDistance && distance > localMaxDistance) continue;\n\n                if (!localDistance || distance < localDistance) {\n                    localDistance = distance;\n                    closestA = ai;\n                    closestB = bi;\n                    closestC = ci;\n                    closestFaceNormal.copy(faceNormal);\n                }\n            }\n\n            if (!localDistance) hits.splice(i, 1);\n\n            // Update hit values from bounds-test\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            // Add unique hit objects on mesh to avoid generating lots of objects\n            if (!mesh.hit.faceNormal) {\n                mesh.hit.localFaceNormal = new Vec3();\n                mesh.hit.faceNormal = new Vec3();\n                mesh.hit.uv = new Vec2();\n                mesh.hit.localNormal = new Vec3();\n                mesh.hit.normal = new Vec3();\n            }\n\n            // Add face normal data which is already computed\n            mesh.hit.localFaceNormal.copy(closestFaceNormal);\n            mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n            // Optional data, opt out to optimise a bit if necessary\n            if (includeUV || includeNormal) {\n                // Calculate barycoords to find uv values at hit point\n                a.fromArray(position.data, closestA * 3);\n                b.fromArray(position.data, closestB * 3);\n                c.fromArray(position.data, closestC * 3);\n                this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n            }\n\n            if (includeUV && attributes.uv) {\n                uvA.fromArray(attributes.uv.data, closestA * 2);\n                uvB.fromArray(attributes.uv.data, closestB * 2);\n                uvC.fromArray(attributes.uv.data, closestC * 2);\n                mesh.hit.uv.set(\n                    uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z,\n                    uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z\n                );\n            }\n\n            if (includeNormal && attributes.normal) {\n                a.fromArray(attributes.normal.data, closestA * 3);\n                b.fromArray(attributes.normal.data, closestB * 3);\n                c.fromArray(attributes.normal.data, closestC * 3);\n                mesh.hit.localNormal.set(\n                    a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z,\n                    a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z,\n                    a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z\n                );\n\n                mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n            }\n        }\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectPlane(plane, origin = this.origin, direction = this.direction) {\n        const xminp = tempVec3a;\n        xminp.sub(plane.origin, origin);\n\n        const a = xminp.dot(plane.normal);\n        const b = direction.dot(plane.normal);\n        // Assuming we don't want to count a ray parallel to the plane as intersecting\n        if (b == 0) return 0;\n        const delta = a / b;\n        if (delta <= 0) return 0;\n        return origin.add(direction.scale(delta));\n    }\n\n    intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n        const ray = tempVec3c;\n        ray.sub(sphere.center, origin);\n        const tca = ray.dot(direction);\n        const d2 = ray.dot(ray) - tca * tca;\n        const radius2 = sphere.radius * sphere.radius;\n        if (d2 > radius2) return 0;\n        const thc = Math.sqrt(radius2 - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n        if (t0 < 0 && t1 < 0) return 0;\n        if (t0 < 0) return t1;\n        return t0;\n    }\n\n    // Ray AABB - Ray Axis aligned bounding box testing\n    intersectBox(box, origin = this.origin, direction = this.direction) {\n        let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n        const invdirx = 1 / direction.x;\n        const invdiry = 1 / direction.y;\n        const invdirz = 1 / direction.z;\n        const min = box.min;\n        const max = box.max;\n        tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n        tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n        tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n        tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n        if (tmin > tYmax || tYmin > tmax) return 0;\n        if (tYmin > tmin) tmin = tYmin;\n        if (tYmax < tmax) tmax = tYmax;\n        tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n        tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n        if (tmin > tZmax || tZmin > tmax) return 0;\n        if (tZmin > tmin) tmin = tZmin;\n        if (tZmax < tmax) tmax = tZmax;\n        if (tmax < 0) return 0;\n        return tmin >= 0 ? tmin : tmax;\n    }\n\n    intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n        // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n        // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n        const edge1 = tempVec3h;\n        const edge2 = tempVec3i;\n        const diff = tempVec3j;\n        edge1.sub(b, a);\n        edge2.sub(c, a);\n        normal.cross(edge1, edge2);\n        let DdN = direction.dot(normal);\n        if (!DdN) return 0;\n        let sign;\n        if (DdN > 0) {\n            if (backfaceCulling) return 0;\n            sign = 1;\n        } else {\n            sign = -1;\n            DdN = -DdN;\n        }\n        diff.sub(origin, a);\n        let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n        if (DdQxE2 < 0) return 0;\n        let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n        if (DdE1xQ < 0) return 0;\n        if (DdQxE2 + DdE1xQ > DdN) return 0;\n        let QdN = -sign * diff.dot(normal);\n        if (QdN < 0) return 0;\n        return QdN / DdN;\n    }\n\n    getBarycoord(point, a, b, c, target = tempVec3h) {\n        // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n        // static/instance method to calculate barycentric coordinates\n        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n        const v0 = tempVec3i;\n        const v1 = tempVec3j;\n        const v2 = tempVec3k;\n        v0.sub(c, a);\n        v1.sub(b, a);\n        v2.sub(point, a);\n        const dot00 = v0.dot(v0);\n        const dot01 = v0.dot(v1);\n        const dot02 = v0.dot(v2);\n        const dot11 = v1.dot(v1);\n        const dot12 = v1.dot(v2);\n        const denom = dot00 * dot11 - dot01 * dot01;\n        if (denom === 0) return target.set(-2, -1, -1);\n        const invDenom = 1 / denom;\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return target.set(1 - u - v, v, u);\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\n\nconst CATMULLROM = 'catmullrom';\nconst CUBICBEZIER = 'cubicbezier';\nconst QUADRATICBEZIER = 'quadraticbezier';\n\n// temp\nconst _a0 = /* @__PURE__ */ new Vec3(),\n    _a1 = /* @__PURE__ */ new Vec3(),\n    _a2 = /* @__PURE__ */ new Vec3(),\n    _a3 = /* @__PURE__ */ new Vec3();\n\n/**\n * Get the control points of cubic bezier curve.\n * @param {*} i\n * @param {*} a\n * @param {*} b\n */\nfunction getCtrlPoint(points, i, a = 0.168, b = 0.168) {\n    if (i < 1) {\n        _a0.sub(points[1], points[0]).scale(a).add(points[0]);\n    } else {\n        _a0.sub(points[i + 1], points[i - 1])\n            .scale(a)\n            .add(points[i]);\n    }\n    if (i > points.length - 3) {\n        const last = points.length - 1;\n        _a1.sub(points[last - 1], points[last])\n            .scale(b)\n            .add(points[last]);\n    } else {\n        _a1.sub(points[i], points[i + 2])\n            .scale(b)\n            .add(points[i + 1]);\n    }\n    return [_a0.clone(), _a1.clone()];\n}\n\nfunction getQuadraticBezierPoint(t, p0, c0, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 2);\n    _a1.copy(c0).scale(2 * k * t);\n    _a2.copy(p1).scale(t ** 2);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2);\n    return ret;\n}\n\nfunction getCubicBezierPoint(t, p0, c0, c1, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 3);\n    _a1.copy(c0).scale(3 * k ** 2 * t);\n    _a2.copy(c1).scale(3 * k * t ** 2);\n    _a3.copy(p1).scale(t ** 3);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2).add(_a3);\n    return ret;\n}\n\nexport class Curve {\n    constructor({ points = [new Vec3(0, 0, 0), new Vec3(0, 1, 0), new Vec3(1, 1, 0), new Vec3(1, 0, 0)], divisions = 12, type = CATMULLROM } = {}) {\n        this.points = points;\n        this.divisions = divisions;\n        this.type = type;\n    }\n\n    _getQuadraticBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 3) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        const p0 = this.points[0];\n        let c0 = this.points[1],\n            p1 = this.points[2];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n            points.push(p);\n        }\n\n        let offset = 3;\n        while (count - offset > 0) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c0);\n            p1 = this.points[offset];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n                points.push(p);\n            }\n            offset++;\n        }\n\n        return points;\n    }\n\n    _getCubicBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 4) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        let p0 = this.points[0],\n            c0 = this.points[1],\n            c1 = this.points[2],\n            p1 = this.points[3];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n            points.push(p);\n        }\n\n        let offset = 4;\n        while (count - offset > 1) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c1);\n            c1 = this.points[offset];\n            p1 = this.points[offset + 1];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n                points.push(p);\n            }\n            offset += 2;\n        }\n\n        return points;\n    }\n\n    _getCatmullRomPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count <= 2) {\n            return this.points;\n        }\n\n        let p0;\n        this.points.forEach((p, i) => {\n            if (i === 0) {\n                p0 = p;\n            } else {\n                const [c0, c1] = getCtrlPoint(this.points, i - 1, a, b);\n                const c = new Curve({\n                    points: [p0, c0, c1, p],\n                    type: CUBICBEZIER,\n                });\n                points.pop();\n                points.push(...c.getPoints(divisions));\n                p0 = p;\n            }\n        });\n\n        return points;\n    }\n\n    getPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const type = this.type;\n\n        if (type === QUADRATICBEZIER) {\n            return this._getQuadraticBezierPoints(divisions);\n        }\n\n        if (type === CUBICBEZIER) {\n            return this._getCubicBezierPoints(divisions);\n        }\n\n        if (type === CATMULLROM) {\n            return this._getCatmullRomPoints(divisions, a, b);\n        }\n\n        return this.points;\n    }\n}\n\nCurve.CATMULLROM = CATMULLROM;\nCurve.CUBICBEZIER = CUBICBEZIER;\nCurve.QUADRATICBEZIER = QUADRATICBEZIER;\n", "/**\n * Abstract base class for path segments.\n * This class contains common methods for all segments types.\n */\nexport default class BaseSegment {\n    constructor() {\n        this._len = -1;\n        this.tiltStart = 0;\n        this.tiltEnd = 0;\n    }\n\n    /**\n     * Get segment length.\n     * @returns {number} segment length\n     */\n    getLength() {\n        if (this._len < 0) {\n            this.updateLength();\n        }\n\n        return this._len;\n    }\n\n    /**\n     * Get tilt angle at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @returns {number} Tilt angle at t\n     */\n    getTiltAt(t) {\n        return this.tiltStart * (1 - t) * this.tiltEnd * t;\n    }\n\n    /**\n     * Creates a clone of this instance\n     * @returns {BaseSegment} cloned instance\n     */\n    clone() {\n        return new this.constructor().copy(this);\n    }\n\n    /**\n     * Copies another segment object to this instance.\n     * @param {BaseSegment} source reference object\n     * @returns {BaseSegment} copy of source object\n     */\n    copy(source) {\n        this._len = source._len;\n        this.tiltStart = source.tiltStart;\n        this.tiltEnd = source.tiltEnd;\n        return this;\n    }\n}\n", "// from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L26\n// Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\nexport const T_VALUES = [\n    -0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745,\n];\n\n// Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\nexport const C_VALUES = [\n    0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759,\n];\n\n/**\n * Convert Degree To Radian\n * @param {number} a Angle in Degrees\n * @returns {number} a Angle in Radians\n */\nexport const toRadian = (a) => (a * Math.PI) / 180;\n\n/**\n * Convert Radian To Degree\n * @param {number} a Angle in Radians\n * @returns {number} a Angle in Radian\n */\nexport const toDegrees = (a) => (180 * a) / Math.PI;\n\nexport const clamp = (val, min, max) => Math.max(min, Math.min(val, max));\nexport const lerp = (t, v0, v1) => v0 * (t - 1) + v1 * t;\n\n/**\n * Fills a rotation matrix with the given sine and cosine of the angle around the given axis\n * This function helps to avoid inverse trigonometry\n * @param {Mat4} out mat4 receiving operation result\n * @param {Vec3} axis the axis to rotate around. Should be normalized\n * @param {number} sin sine of rotation angle\n * @param {number} cos cosine of rotation angle\n * @returns {Mat4} out\n */\nexport function mat4fromRotationSinCos(out, axis, sin, cos) {\n    const x = axis[0];\n    const y = axis[1];\n    const z = axis[2];\n    const t = 1 - cos;\n\n    out[0] = x * x * t + cos;\n    out[1] = y * x * t + z * sin;\n    out[2] = z * x * t - y * sin;\n    out[3] = 0;\n    out[4] = x * y * t - z * sin;\n    out[5] = y * y * t + cos;\n    out[6] = z * y * t + x * sin;\n    out[7] = 0;\n    out[8] = x * z * t + y * sin;\n    out[9] = y * z * t - x * sin;\n    out[10] = z * z * t + cos;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Rotates the normal and binormal around its tangent by the given angle.\n *\n * see: https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n * @param {number} angle rotation angle\n * @param {Vec3} norm unit normal vector\n * @param {Vec3} binorm unit binormal vector\n * @param {Vec3} outNorm optional normal output vector. If not present then normal vector changes in place\n * @param {Vec3} outBinorm optional binormal output vector. If not present then binormal vector changes in place\n */\nexport function rotateNormalBinormal(angle, norm, binorm, outNorm = norm, outBinorm = binorm) {\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n\n    const nx = c * norm.x + s * binorm.x;\n    const ny = c * norm.y + s * binorm.y;\n    const nz = c * norm.z + s * binorm.z;\n\n    const bx = c * binorm.x - s * norm.x;\n    const by = c * binorm.y - s * norm.y;\n    const bz = c * binorm.z - s * norm.z;\n\n    outNorm.set(nx, ny, nz);\n    outBinorm.set(bx, by, bz);\n}\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction cubicBezier(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (k * k * k * p0) +\n        (3 * k * k * t * p1) +\n        (3 * k * t * t * p2) +\n        (t * t * t * p3)\n    );\n}\n\nfunction cubicBezierDeriv(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (3 * k * k * (p1 - p0)) +\n        (6 * k * t * (p2 - p1)) +\n        (3 * t * t * (p3 - p2))\n    );\n}\n\nexport default class CubicBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, p3, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = cubicBezier(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezier(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezier(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = cubicBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p3;\n    }\n}\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction quadraticBezier(t, p0, p1, p2) {\n    const k = 1 - t;\n    return k * k * p0 + 2 * k * t * p1 + t * t * p2;\n}\n\nfunction quadraticBezierDeriv(t, p0, p1, p2) {\n    const k = 1 - t;\n    return 2 * k * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\nexport default class QuadraticBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = quadraticBezier(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezier(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezier(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = quadraticBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p2;\n    }\n}\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { lerp as lerp3 } from '../../math/functions/Vec3Func.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nexport default class LineSegment extends BaseSegment {\n    constructor(p0, p1, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        this._len = tempVec3.sub(this.p1, this.p0).len();\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        lerp3(out, this.p0, this.p1, t);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return out.sub(this.p1, this.p0).normalize();\n    }\n\n    lastPoint() {\n        return this.p1;\n    }\n}\n", "import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nfunction throwIfNullProperty(property, message) {\n    if (this[property] == null) throw new Error(message);\n}\n\nexport class Path {\n    constructor() {\n        this._segments = [];\n        this._lengthOffsets = null;\n        this._totalLength = -1;\n        this._lastPoint = null;\n        this._lastTilt = 0;\n\n        this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n\n        this.tiltFunction = null;\n    }\n\n    moveTo(p, tilt = 0) {\n        this._totalLength = -1;\n        this._lastPoint = p;\n        this._lastTilt = tilt;\n    }\n\n    bezierCurveTo(cp1, cp2, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    quadraticCurveTo(cp, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    lineTo(p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    addSegment(segment) {\n        this._totalLength = -1;\n        this._lastPoint = segment.lastPoint();\n        this._lastTilt = segment.tiltEnd;\n        this._segments.push(segment);\n        return this;\n    }\n\n    getSegments() {\n        return this._segments;\n    }\n\n    updateLength() {\n        const n = this._segments.length;\n        this._lengthOffsets = new Array(n);\n\n        let offset = 0;\n        for (let i = 0; i < n; i++) {\n            this._lengthOffsets[i] = offset;\n            offset += this._segments[i].getLength();\n        }\n\n        this._totalLength = offset;\n    }\n\n    getLength() {\n        if (this._totalLength < 0) {\n            this.updateLength();\n        }\n\n        return this._totalLength;\n    }\n\n    /**\n     * Finding a path segment at a given absolute length distance\n     * @param {number} len absolute length distance\n     * @returns {[number, number]} [_segment index_, _relative segment distance_]\n     */\n    findSegmentIndexAtLength(len) {\n        const totalLength = this.getLength();\n\n        if (len <= 0) {\n            return [0, 0];\n        }\n\n        if (len >= totalLength) {\n            return [this._segments.length - 1, 1];\n        }\n\n        let start = 0;\n        let end = this._lengthOffsets.length - 1;\n        let index = -1;\n        let mid;\n\n        while (start <= end) {\n            mid = Math.ceil((start + end) / 2);\n\n            if (mid === 0 || mid === this._lengthOffsets.length - 1 || (len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1])) {\n                index = mid;\n                break;\n            } else if (len < this._lengthOffsets[mid]) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        const seg = this._segments[index];\n        const segLen = seg.getLength();\n        const t = (len - this._lengthOffsets[index]) / segLen;\n\n        return [index, t];\n    }\n\n    getPointAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getPointAt(t, out);\n    }\n\n    getPointAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getPointAtLength(t * totalLength, out);\n    }\n\n    getTangentAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTangentAt(t, out);\n    }\n\n    getTangentAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getTangentAtLength(t * totalLength, out);\n    }\n\n    getTiltAtLength(len) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTiltAt(t);\n    }\n\n    getTiltAt(t) {\n        const totalLength = this.getLength();\n        return this.getTiltAtLength(t * totalLength);\n    }\n\n    /**\n     * Get sequence of points using `getPointAt(t)`\n     * @param {number} divisions number of subdivisions\n     * @returns {Vec3[]} array of points\n     */\n    getPoints(divisions = 64) {\n        const points = new Array(divisions + 1);\n        for (let i = 0; i <= divisions; i++) {\n            points[i] = this.getPointAt(i / divisions);\n        }\n        return points;\n    }\n\n    /**\n     * Generates the Frenet Frames.\n     * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n     * @param {number} divisions number of subdivisions\n     * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n     */\n    computeFrenetFrames(divisions = 64, closed = false) {\n        const tangents = new Array(divisions + 1);\n        const tilts = new Array(divisions + 1);\n\n        const tiltFunction = this.tiltFunction ?? ((a) => a);\n\n        // compute the tangent vectors and tilt for each segment on the curve\n        const totalLength = this.getLength();\n        for (let i = 0; i <= divisions; i++) {\n            const [si, st] = this.findSegmentIndexAtLength((totalLength * i) / divisions);\n            const segment = this._segments[si];\n            tangents[i] = segment.getTangentAt(st);\n            tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n        }\n\n        const tx = Math.abs(tangents[0].x);\n        const ty = Math.abs(tangents[0].y);\n        const tz = Math.abs(tangents[0].z);\n\n        const normal = new Vec3();\n        if (tx < ty && tx < tz) {\n            normal.set(1, 0, 0);\n        } else if (ty < tx && ty < tz) {\n            normal.set(0, 1, 0);\n        } else {\n            normal.set(0, 0, 1);\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n        const normals = new Array(divisions + 1);\n        const binormals = new Array(divisions + 1);\n        normals[0] = new Vec3();\n        binormals[0] = new Vec3();\n\n        tempVec3.cross(tangents[0], normal).normalize();\n        normals[0].cross(tangents[0], tempVec3);\n        binormals[0].cross(tangents[0], normals[0]);\n\n        // compute the slowly-varying normal vector for each segment on the curve\n        for (let i = 1; i < tangents.length; i++) {\n            normals[i] = normals[i - 1].clone();\n            binormals[i] = new Vec3();\n\n            tempVec3.cross(tangents[i - 1], tangents[i]);\n            const crossLen = tempVec3.len();\n\n            if (crossLen > Number.EPSILON) {\n                tempVec3.scale(1 / crossLen); // nomalize\n                const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n                const sinTheta = clamp(crossLen, -1, 1);\n\n                mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n                normals[i].applyMatrix4(tempMat4);\n            }\n\n            binormals[i].cross(tangents[i], normals[i]);\n        }\n\n        // add tilt twisting\n        for (let i = 0; i < tilts.length; i++) {\n            rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n        if (closed === true) {\n            const normalLast = normals[normals.length - 1];\n            let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n\n            if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n                step = -step;\n            }\n\n            for (let i = 1; i < normals.length - 1; i++) {\n                const angle = step * i;\n                rotateNormalBinormal(angle, normals[i], binormals[i]);\n                tilts[i] += toDegrees(angle);\n            }\n\n            normals[normals.length - 1] = normals[0].clone();\n            binormals[binormals.length - 1] = binormals[0].clone();\n        }\n\n        return { tangents, normals, binormals, tilts };\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\n// helper variables\nconst vertex = /* @__PURE__ */ new Vec3();\nconst normal = /* @__PURE__ */ new Vec3();\nconst uv = /* @__PURE__ */ new Vec2();\nconst point = /* @__PURE__ */ new Vec3();\n\nexport class Tube extends Geometry {\n    constructor(gl, { path, radius = 1, tubularSegments = 64, radialSegments = 8, closed = false, attributes = {} } = {}) {\n        super(gl, attributes);\n\n        this.path = path;\n        this.radius = radius;\n        this.tubularSegments = tubularSegments;\n        this.radialSegments = radialSegments;\n        this.closed = closed;\n\n        this.frenetFrames = path.computeFrenetFrames(tubularSegments, closed);\n\n        const numVertices = (tubularSegments + 1) * (radialSegments + 1);\n        const numIndices = tubularSegments * radialSegments * 6;\n        this.positions = new Float32Array(numVertices * 3);\n        this.normals = new Float32Array(numVertices * 3);\n        this.uvs = new Float32Array(numVertices * 2);\n        this.indices = numVertices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        // create buffer data\n        this._generateAttributes();\n        this._generateIndices();\n\n        this.addAttribute('position', { size: 3, data: this.positions });\n        this.addAttribute('normal', { size: 3, data: this.normals });\n        this.addAttribute('uv', { size: 2, data: this.uvs });\n        this.setIndex({ data: this.indices });\n    }\n\n    _generateAttributes() {\n        for (let i = 0; i <= this.tubularSegments; i++) {\n            let ci = i;\n            if (i === this.tubularSegments) {\n                // if the geometry is not closed, generate the last row of vertices and normals\n                // at the regular position on the given path\n                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n                ci = this.closed ? 0 : this.tubularSegments;\n            }\n\n            this.path.getPointAt(ci / this.tubularSegments, point);\n            // retrieve corresponding normal and binormal\n            const N = this.frenetFrames.normals[ci];\n            const B = this.frenetFrames.binormals[ci];\n\n            // generate normals and vertices for the current segment\n            for (let j = 0; j <= this.radialSegments; j++) {\n                const v = (j / this.radialSegments) * Math.PI * 2;\n                const sin = Math.sin(v);\n                const cos = -Math.cos(v);\n\n                const idx = i * (this.radialSegments + 1) + j;\n\n                // normal\n                normal.x = cos * N.x + sin * B.x;\n                normal.y = cos * N.y + sin * B.y;\n                normal.z = cos * N.z + sin * B.z;\n                // normal.normalize(); // ???\n                this.normals.set(normal, idx * 3);\n\n                // vertex\n                vertex.x = point.x + this.radius * normal.x;\n                vertex.y = point.y + this.radius * normal.y;\n                vertex.z = point.z + this.radius * normal.z;\n                this.positions.set(vertex, idx * 3);\n\n                // uv\n                uv.x = i / this.tubularSegments;\n                uv.y = j / this.radialSegments;\n                this.uvs.set(uv, idx * 2);\n            }\n        }\n    }\n\n    _generateIndices() {\n        for (let j = 1; j <= this.tubularSegments; j++) {\n            for (let i = 1; i <= this.radialSegments; i++) {\n                const a = (this.radialSegments + 1) * (j - 1) + (i - 1);\n                const b = (this.radialSegments + 1) * j + (i - 1);\n                const c = (this.radialSegments + 1) * j + i;\n                const d = (this.radialSegments + 1) * (j - 1) + i;\n\n                const idx = (j - 1) * this.radialSegments + (i - 1);\n                this.indices.set([a, b, d, b, c, d], idx * 6);\n            }\n        }\n    }\n}\n", "import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Post {\n    constructor(\n        gl,\n        {\n            width,\n            height,\n            dpr,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = gl.LINEAR,\n            geometry = new Triangle(gl),\n            targetOnly = null,\n            depth = true,\n        } = {}\n    ) {\n        this.gl = gl;\n\n        this.passes = [];\n\n        this.geometry = geometry;\n\n        this.uniform = { value: null };\n        this.targetOnly = targetOnly;\n\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        let options = {\n            dpr: this.dpr,\n            width: this.resolutionWidth,\n            height: this.resolutionHeight,\n            wrapS,\n            wrapT,\n            minFilter,\n            magFilter,\n            depth,\n        };\n\n        const fbo = (this.fbo = {\n            read: new RenderTarget(this.gl, options),\n            write: new RenderTarget(this.gl, options),\n            swap: () => {\n                let temp = fbo.read;\n                fbo.read = fbo.write;\n                fbo.write = temp;\n            },\n        });\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = { value: this.fbo.read.texture };\n\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    resize({ width, height, dpr } = {}) {\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        this.fbo.read.setSize(this.resolutionWidth, this.resolutionHeight);\n        this.fbo.write.setSize(this.resolutionWidth, this.resolutionHeight);\n    }\n\n    // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n    render({ scene, camera, texture, target = null, update = true, sort = true, frustumCull = true, beforePostCallbacks }) {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        if (!texture) {\n            this.gl.renderer.render({\n                scene,\n                camera,\n                target: enabledPasses.length || (!target && this.targetOnly) ? this.fbo.write : target,\n                update,\n                sort,\n                frustumCull,\n            });\n            this.fbo.swap();\n\n            // Callback after rendering scene, but before post effects\n            if (beforePostCallbacks) beforePostCallbacks.forEach((f) => f && f());\n        }\n\n        enabledPasses.forEach((pass, i) => {\n            pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n                clear: true,\n            });\n            this.fbo.swap();\n        });\n\n        this.uniform.value = this.fbo.read.texture;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst prevPos = /* @__PURE__ */ new Vec3();\nconst prevRot = /* @__PURE__ */ new Quat();\nconst prevScl = /* @__PURE__ */ new Vec3();\n\nconst nextPos = /* @__PURE__ */ new Vec3();\nconst nextRot = /* @__PURE__ */ new Quat();\nconst nextScl = /* @__PURE__ */ new Vec3();\n\nexport class Animation {\n    constructor({ objects, data }) {\n        this.objects = objects;\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = 1;\n        this.duration = data.frames.length - 1;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = this.elapsed % this.duration;\n\n        const floorFrame = Math.floor(elapsed);\n        const blend = elapsed - floorFrame;\n        const prevKey = this.data.frames[floorFrame];\n        const nextKey = this.data.frames[(floorFrame + 1) % this.duration];\n\n        this.objects.forEach((object, i) => {\n            prevPos.fromArray(prevKey.position, i * 3);\n            prevRot.fromArray(prevKey.quaternion, i * 4);\n            prevScl.fromArray(prevKey.scale, i * 3);\n\n            nextPos.fromArray(nextKey.position, i * 3);\n            nextRot.fromArray(nextKey.quaternion, i * 4);\n            nextScl.fromArray(nextKey.scale, i * 3);\n\n            prevPos.lerp(nextPos, blend);\n            prevRot.slerp(nextRot, blend);\n            prevScl.lerp(nextScl, blend);\n\n            object.position.lerp(prevPos, weight);\n            object.quaternion.slerp(prevRot, weight);\n            object.scale.lerp(prevScl, weight);\n        });\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Transform } from '../core/Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\nimport { Animation } from './Animation.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Skin extends Mesh {\n    constructor(gl, { rig, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n\n        this.createBones(rig);\n        this.createBoneTexture();\n        this.animations = [];\n\n        Object.assign(this.program.uniforms, {\n            boneTexture: { value: this.boneTexture },\n            boneTextureSize: { value: this.boneTextureSize },\n        });\n    }\n\n    createBones(rig) {\n        // Create root so that can simply update world matrix of whole skeleton\n        this.root = new Transform();\n\n        // Create bones\n        this.bones = [];\n        if (!rig.bones || !rig.bones.length) return;\n        for (let i = 0; i < rig.bones.length; i++) {\n            const bone = new Transform();\n\n            // Set initial values (bind pose)\n            bone.position.fromArray(rig.bindPose.position, i * 3);\n            bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n            bone.scale.fromArray(rig.bindPose.scale, i * 3);\n\n            this.bones.push(bone);\n        }\n\n        // Once created, set the hierarchy\n        rig.bones.forEach((data, i) => {\n            this.bones[i].name = data.name;\n            if (data.parent === -1) return this.bones[i].setParent(this.root);\n            this.bones[i].setParent(this.bones[data.parent]);\n        });\n\n        // Then update to calculate world matrices\n        this.root.updateMatrixWorld(true);\n\n        // Store inverse of bind pose to calculate differences\n        this.bones.forEach((bone) => {\n            bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\n        });\n    }\n\n    createBoneTexture() {\n        if (!this.bones.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    addAnimation(data) {\n        const animation = new Animation({ objects: this.bones, data });\n        this.animations.push(animation);\n        return animation;\n    }\n\n    update() {\n        // Calculate combined animation weight\n        let total = 0;\n        this.animations.forEach((animation) => (total += animation.weight));\n\n        this.animations.forEach((animation, i) => {\n            // force first animation to set in order to reset frame\n            animation.update(total, i === 0);\n        });\n    }\n\n    draw({ camera } = {}) {\n        // Update world matrices manually, as not part of scene graph\n        this.root.updateMatrixWorld(true);\n\n        // Update bone texture\n        this.bones.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        if (this.boneTexture) this.boneTexture.needsUpdate = true;\n\n        super.draw({ camera });\n    }\n}\n", "export function Text({\n    font,\n    text,\n    width = Infinity,\n    align = 'left',\n    size = 1,\n    letterSpacing = 0,\n    lineHeight = 1.4,\n    wordSpacing = 0,\n    wordBreak = false,\n}) {\n    const _this = this;\n    let glyphs, buffers;\n    let fontHeight, baseline, scale;\n\n    const newline = /\\n/;\n    const whitespace = /\\s/;\n\n    {\n        parseFont();\n        createGeometry();\n    }\n\n    function parseFont() {\n        glyphs = {};\n        font.chars.forEach((d) => (glyphs[d.char] = d));\n    }\n\n    function createGeometry() {\n        fontHeight = font.common.lineHeight;\n        baseline = font.common.base;\n\n        // Use baseline so that actual text height is as close to 'size' value as possible\n        scale = size / baseline;\n\n        // Strip spaces and newlines to get actual character length for buffers\n        let chars = text.replace(/[ \\n]/g, '');\n        let numChars = chars.length;\n\n        // Create output buffers\n        buffers = {\n            position: new Float32Array(numChars * 4 * 3),\n            uv: new Float32Array(numChars * 4 * 2),\n            id: new Float32Array(numChars * 4),\n            index: new Uint16Array(numChars * 6),\n        };\n\n        // Set values for buffers that don't require calculation\n        for (let i = 0; i < numChars; i++) {\n            buffers.id.set([i, i, i, i], i * 4);\n            buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n        }\n\n        layout();\n    }\n\n    function layout() {\n        const lines = [];\n\n        let cursor = 0;\n\n        let wordCursor = 0;\n        let wordWidth = 0;\n        let line = newLine();\n\n        function newLine() {\n            const line = {\n                width: 0,\n                glyphs: [],\n            };\n            lines.push(line);\n            wordCursor = cursor;\n            wordWidth = 0;\n            return line;\n        }\n\n        let maxTimes = 100;\n        let count = 0;\n        while (cursor < text.length && count < maxTimes) {\n            count++;\n\n            const char = text[cursor];\n\n            // Skip whitespace at start of line\n            if (!line.width && whitespace.test(char)) {\n                cursor++;\n                wordCursor = cursor;\n                wordWidth = 0;\n                continue;\n            }\n\n            // If newline char, skip to next line\n            if (newline.test(char)) {\n                cursor++;\n                line = newLine();\n                continue;\n            }\n\n            const glyph = glyphs[char] || glyphs[' '];\n\n            // Find any applicable kern pairs\n            if (line.glyphs.length) {\n                const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n                let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n                line.width += kern;\n                wordWidth += kern;\n            }\n\n            // add char to line\n            line.glyphs.push([glyph, line.width]);\n\n            // calculate advance for next glyph\n            let advance = 0;\n\n            // If whitespace, update location of current word for line breaks\n            if (whitespace.test(char)) {\n                wordCursor = cursor;\n                wordWidth = 0;\n\n                // Add wordspacing\n                advance += wordSpacing * size;\n            } else {\n                // Add letterspacing\n                advance += letterSpacing * size;\n            }\n\n            advance += glyph.xadvance * scale;\n\n            line.width += advance;\n            wordWidth += advance;\n\n            // If width defined\n            if (line.width > width) {\n                // If can break words, undo latest glyph if line not empty and create new line\n                if (wordBreak && line.glyphs.length > 1) {\n                    line.width -= advance;\n                    line.glyphs.pop();\n                    line = newLine();\n                    continue;\n\n                    // If not first word, undo current word and cursor and create new line\n                } else if (!wordBreak && wordWidth !== line.width) {\n                    let numGlyphs = cursor - wordCursor + 1;\n                    line.glyphs.splice(-numGlyphs, numGlyphs);\n                    cursor = wordCursor;\n                    line.width -= wordWidth;\n                    line = newLine();\n                    continue;\n                }\n            }\n\n            cursor++;\n            // Reset infinite loop catch\n            count = 0;\n        }\n\n        // Remove last line if empty\n        if (!line.width) lines.pop();\n\n        populateBuffers(lines);\n    }\n\n    function populateBuffers(lines) {\n        const texW = font.common.scaleW;\n        const texH = font.common.scaleH;\n\n        // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n        let y = 0.07 * size;\n        let j = 0;\n\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n            let line = lines[lineIndex];\n\n            for (let i = 0; i < line.glyphs.length; i++) {\n                const glyph = line.glyphs[i][0];\n                let x = line.glyphs[i][1];\n\n                if (align === 'center') {\n                    x -= line.width * 0.5;\n                } else if (align === 'right') {\n                    x -= line.width;\n                }\n\n                // If space, don't add to geometry\n                if (whitespace.test(glyph.char)) continue;\n\n                // Apply char sprite offsets\n                x += glyph.xoffset * scale;\n                y -= glyph.yoffset * scale;\n\n                // each letter is a quad. axis bottom left\n                let w = glyph.width * scale;\n                let h = glyph.height * scale;\n                buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n\n                let u = glyph.x / texW;\n                let uw = glyph.width / texW;\n                let v = 1.0 - glyph.y / texH;\n                let vh = glyph.height / texH;\n                buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);\n\n                // Reset cursor to baseline\n                y += glyph.yoffset * scale;\n\n                j++;\n            }\n\n            y -= size * lineHeight;\n        }\n\n        _this.buffers = buffers;\n        _this.numLines = lines.length;\n        _this.height = _this.numLines * size * lineHeight;\n        _this.width = Math.max(...lines.map((line) => line.width));\n    }\n\n    function getKernPairOffset(id1, id2) {\n        for (let i = 0; i < font.kernings.length; i++) {\n            let k = font.kernings[i];\n            if (k.first < id1) continue;\n            if (k.second < id2) continue;\n            if (k.first > id1) return 0;\n            if (k.first === id1 && k.second > id2) return 0;\n            return k.amount;\n        }\n        return 0;\n    }\n\n    // Update buffers to layout with new layout\n    this.resize = function (options) {\n        ({ width } = options);\n        layout();\n    };\n\n    // Completely change text (like creating new Text)\n    this.update = function (options) {\n        ({ text } = options);\n        createGeometry();\n    };\n}\n", "import { Program } from '../core/Program.js';\n\nconst vertex = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    attribute vec3 position;\n    attribute vec3 normal;\n\n    uniform mat3 normalMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vNormal;\n\n    void main() {\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    varying vec3 vNormal;\n\n    void main() {\n        gl_FragColor.rgb = normalize(vNormal);\n        gl_FragColor.a = 1.0;\n    }\n`;\n\nexport function NormalProgram(gl) {\n    return new Program(gl, {\n        vertex: vertex,\n        fragment: fragment,\n        cullFace: false,\n    });\n}\n", "import { RenderTarget } from '../core/RenderTarget.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Flowmap {\n    constructor(\n        gl,\n        {\n            size = 128, // default size of the render targets\n            falloff = 0.3, // size of the stamp, percentage of the size\n            alpha = 1, // opacity of the stamp\n            dissipation = 0.98, // affects the speed that the stamp fades. Closer to 1 is slower\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        } = {}\n    ) {\n        const _this = this;\n        this.gl = gl;\n\n        // output uniform containing render target textures\n        this.uniform = { value: null };\n\n        this.mask = {\n            read: null,\n            write: null,\n\n            // Helper function to ping pong the render targets and update the uniform\n            swap: () => {\n                let temp = _this.mask.read;\n                _this.mask.read = _this.mask.write;\n                _this.mask.write = temp;\n                _this.uniform.value = _this.mask.read.texture;\n            },\n        };\n\n        {\n            createFBOs();\n\n            this.aspect = 1;\n            this.mouse = new Vec2();\n            this.velocity = new Vec2();\n\n            this.mesh = initProgram();\n        }\n\n        function createFBOs() {\n            // Requested type not supported, fall back to half float\n            if (!type) type = gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES;\n\n            let minFilter = (() => {\n                if (gl.renderer.isWebgl2) return gl.LINEAR;\n                if (gl.renderer.extensions[`OES_texture_${type === gl.FLOAT ? '' : 'half_'}float_linear`]) return gl.LINEAR;\n                return gl.NEAREST;\n            })();\n\n            const options = {\n                width: size,\n                height: size,\n                type,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n                minFilter,\n                depth: false,\n            };\n\n            _this.mask.read = new RenderTarget(gl, options);\n            _this.mask.write = new RenderTarget(gl, options);\n            _this.mask.swap();\n        }\n\n        function initProgram() {\n            return new Mesh(gl, {\n                // Triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n                geometry: new Triangle(gl),\n\n                program: new Program(gl, {\n                    vertex,\n                    fragment,\n                    uniforms: {\n                        tMap: _this.uniform,\n\n                        uFalloff: { value: falloff * 0.5 },\n                        uAlpha: { value: alpha },\n                        uDissipation: { value: dissipation },\n\n                        // User needs to update these\n                        uAspect: { value: 1 },\n                        uMouse: { value: _this.mouse },\n                        uVelocity: { value: _this.velocity },\n                    },\n                    depthTest: false,\n                }),\n            });\n        }\n    }\n\n    update() {\n        this.mesh.program.uniforms.uAspect.value = this.aspect;\n\n        this.gl.renderer.render({\n            scene: this.mesh,\n            target: this.mask.write,\n            clear: false,\n        });\n        this.mask.swap();\n    }\n}\n\nconst vertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n\n    uniform float uFalloff;\n    uniform float uAlpha;\n    uniform float uDissipation;\n    \n    uniform float uAspect;\n    uniform vec2 uMouse;\n    uniform vec2 uVelocity;\n\n    varying vec2 vUv;\n\n    void main() {\n        vec4 color = texture2D(tMap, vUv) * uDissipation;\n\n        vec2 cursor = vUv - uMouse;\n        cursor.x *= uAspect;\n\n        vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));\n        float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;\n\n        color.rgb = mix(color.rgb, stamp, vec3(falloff));\n\n        gl_FragColor = color;\n    }\n`;\n", "import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class GPGPU {\n    constructor(\n        gl,\n        {\n            // Always pass in array of vec4s (RGBA values within texture)\n            data = new Float32Array(16),\n            geometry = new Triangle(gl),\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        }\n    ) {\n        this.gl = gl;\n        const initialData = data;\n        this.passes = [];\n        this.geometry = geometry;\n        this.dataLength = initialData.length / 4;\n\n        // Windows and iOS only like power of 2 textures\n        // Find smallest PO2 that fits data\n        this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n        // Create coords for output texture\n        this.coords = new Float32Array(this.dataLength * 2);\n        for (let i = 0; i < this.dataLength; i++) {\n            const x = (i % this.size) / this.size; // to add 0.5 to be center pixel ?\n            const y = Math.floor(i / this.size) / this.size;\n            this.coords.set([x, y], i * 2);\n        }\n\n        // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n        const floatArray = (() => {\n            if (initialData.length === this.size * this.size * 4) {\n                return initialData;\n            } else {\n                const a = new Float32Array(this.size * this.size * 4);\n                a.set(initialData);\n                return a;\n            }\n        })();\n\n        // Create output texture uniform using input float texture with initial data\n        this.uniform = {\n            value: new Texture(gl, {\n                image: floatArray,\n                target: gl.TEXTURE_2D,\n                type: gl.FLOAT,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n                wrapS: gl.CLAMP_TO_EDGE,\n                wrapT: gl.CLAMP_TO_EDGE,\n                generateMipmaps: false,\n                minFilter: gl.NEAREST,\n                magFilter: gl.NEAREST,\n                width: this.size,\n                flipY: false,\n            }),\n        };\n\n        // Create FBOs\n        const options = {\n            width: this.size,\n            height: this.size,\n            type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n            format: gl.RGBA,\n            internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n            minFilter: gl.NEAREST,\n            depth: false,\n            unpackAlignment: 1,\n        };\n\n        this.fbo = {\n            read: new RenderTarget(gl, options),\n            write: new RenderTarget(gl, options),\n            swap: () => {\n                let temp = this.fbo.read;\n                this.fbo.read = this.fbo.write;\n                this.fbo.write = temp;\n                this.uniform.value = this.fbo.read.texture;\n            },\n        };\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = this.uniform;\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    render() {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        enabledPasses.forEach((pass, i) => {\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: this.fbo.write,\n                clear: false,\n            });\n            this.fbo.swap();\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n", "import { Geometry } from '../core/Geometry.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Color } from '../math/Color.js';\n\nconst tmp = /* @__PURE__ */ new Vec3();\n\nexport class Polyline {\n    constructor(\n        gl,\n        {\n            points, // Array of Vec3s\n            vertex = defaultVertex,\n            fragment = defaultFragment,\n            uniforms = {},\n            attributes = {}, // For passing in custom attribs\n        }\n    ) {\n        this.gl = gl;\n        this.points = points;\n        this.count = points.length;\n\n        // Create buffers\n        this.position = new Float32Array(this.count * 3 * 2);\n        this.prev = new Float32Array(this.count * 3 * 2);\n        this.next = new Float32Array(this.count * 3 * 2);\n        const side = new Float32Array(this.count * 1 * 2);\n        const uv = new Float32Array(this.count * 2 * 2);\n        const index = new Uint16Array((this.count - 1) * 3 * 2);\n\n        // Set static buffers\n        for (let i = 0; i < this.count; i++) {\n            side.set([-1, 1], i * 2);\n            const v = i / (this.count - 1);\n            uv.set([0, v, 1, v], i * 4);\n\n            if (i === this.count - 1) continue;\n            const ind = i * 2;\n            index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n            index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n        }\n\n        const geometry = (this.geometry = new Geometry(\n            gl,\n            Object.assign(attributes, {\n                position: { size: 3, data: this.position },\n                prev: { size: 3, data: this.prev },\n                next: { size: 3, data: this.next },\n                side: { size: 1, data: side },\n                uv: { size: 2, data: uv },\n                index: { size: 1, data: index },\n            })\n        ));\n\n        // Populate dynamic buffers\n        this.updateGeometry();\n\n        if (!uniforms.uResolution) this.resolution = uniforms.uResolution = { value: new Vec2() };\n        if (!uniforms.uDPR) this.dpr = uniforms.uDPR = { value: 1 };\n        if (!uniforms.uThickness) this.thickness = uniforms.uThickness = { value: 1 };\n        if (!uniforms.uColor) this.color = uniforms.uColor = { value: new Color('#000') };\n        if (!uniforms.uMiter) this.miter = uniforms.uMiter = { value: 1 };\n\n        // Set size uniforms' values\n        this.resize();\n\n        const program = (this.program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms,\n        }));\n\n        this.mesh = new Mesh(gl, { geometry, program });\n    }\n\n    updateGeometry() {\n        this.points.forEach((p, i) => {\n            p.toArray(this.position, i * 3 * 2);\n            p.toArray(this.position, i * 3 * 2 + 3);\n\n            if (!i) {\n                // If first point, calculate prev using the distance to 2nd point\n                tmp.copy(p)\n                    .sub(this.points[i + 1])\n                    .add(p);\n                tmp.toArray(this.prev, i * 3 * 2);\n                tmp.toArray(this.prev, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.next, (i - 1) * 3 * 2);\n                p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n            }\n\n            if (i === this.points.length - 1) {\n                // If last point, calculate next using distance to 2nd last point\n                tmp.copy(p)\n                    .sub(this.points[i - 1])\n                    .add(p);\n                tmp.toArray(this.next, i * 3 * 2);\n                tmp.toArray(this.next, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.prev, (i + 1) * 3 * 2);\n                p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n            }\n        });\n\n        this.geometry.attributes.position.needsUpdate = true;\n        this.geometry.attributes.prev.needsUpdate = true;\n        this.geometry.attributes.next.needsUpdate = true;\n    }\n\n    // Only need to call if not handling resolution uniforms manually\n    resize() {\n        // Update automatic uniforms if not overridden\n        if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n        if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n", "import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\n\nexport class Shadow {\n    constructor(gl, { light = new Camera(gl), width = 1024, height = width }) {\n        this.gl = gl;\n\n        this.light = light;\n\n        this.target = new RenderTarget(gl, { width, height });\n        this.targetUniform = { value: this.target.texture };\n\n        this.depthProgram = new Program(gl, {\n            vertex: defaultVertex,\n            fragment: defaultFragment,\n            cullFace: false,\n        });\n\n        this.castMeshes = [];\n    }\n\n    add({\n        mesh,\n        receive = true,\n        cast = true,\n        vertex = defaultVertex,\n        fragment = defaultFragment,\n        uniformProjection = 'shadowProjectionMatrix',\n        uniformView = 'shadowViewMatrix',\n        uniformTexture = 'tShadow',\n    }) {\n        // Add uniforms to existing program\n        if (receive && !mesh.program.uniforms[uniformProjection]) {\n            mesh.program.uniforms[uniformProjection] = { value: this.light.projectionMatrix };\n            mesh.program.uniforms[uniformView] = { value: this.light.viewMatrix };\n            mesh.program.uniforms[uniformTexture] = this.targetUniform;\n        }\n\n        if (!cast) return;\n        this.castMeshes.push(mesh);\n\n        // Store program for when switching between depth override\n        mesh.colorProgram = mesh.program;\n\n        // Check if depth program already attached\n        if (mesh.depthProgram) return;\n\n        // Use global depth override if nothing custom passed in\n        if (vertex === defaultVertex && fragment === defaultFragment) {\n            mesh.depthProgram = this.depthProgram;\n            return;\n        }\n\n        // Create custom override program\n        mesh.depthProgram = new Program(this.gl, {\n            vertex,\n            fragment,\n            cullFace: false,\n        });\n    }\n\n    setSize({ width = 1024, height = width }) {\n        this.target = new RenderTarget(this.gl, { width, height });\n        this.targetUniform.value = this.target.texture;\n    }\n\n    render({ scene }) {\n        // For depth render, replace program with depth override.\n        // Hide meshes not casting shadows.\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.depthProgram;\n            } else {\n                node.isForceVisibility = node.visible;\n                node.visible = false;\n            }\n        });\n\n        // Render the depth shadow map using the light as the camera\n        this.gl.renderer.render({\n            scene,\n            camera: this.light,\n            target: this.target,\n        });\n\n        // Then switch the program back to the normal one\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.colorProgram;\n            } else {\n                node.visible = node.isForceVisibility;\n            }\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n", "import { Texture } from '../core/Texture.js';\n\n// TODO: Support cubemaps\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nexport class KTXTexture extends Texture {\n    constructor(gl, { buffer, wrapS = gl.CLAMP_TO_EDGE, wrapT = gl.CLAMP_TO_EDGE, anisotropy = 0, minFilter, magFilter } = {}) {\n        super(gl, {\n            generateMipmaps: false,\n            wrapS,\n            wrapT,\n            anisotropy,\n            minFilter,\n            magFilter,\n        });\n\n        if (buffer) return this.parseBuffer(buffer);\n    }\n\n    parseBuffer(buffer) {\n        const ktx = new KhronosTextureContainer(buffer);\n        ktx.mipmaps.isCompressedTexture = true;\n\n        // Update texture\n        this.image = ktx.mipmaps;\n        this.internalFormat = ktx.glInternalFormat;\n        if (ktx.numberOfMipmapLevels > 1) {\n            if (this.minFilter === this.gl.LINEAR) this.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        } else {\n            if (this.minFilter === this.gl.NEAREST_MIPMAP_LINEAR) this.minFilter = this.gl.LINEAR;\n        }\n\n        // TODO: support cube maps\n        // ktx.numberOfFaces\n    }\n}\n\nfunction KhronosTextureContainer(buffer) {\n    const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n    const id = new Uint8Array(buffer, 0, 12);\n    for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) return console.error('File missing KTX identifier');\n\n    // TODO: Is this always 4? Tested: [android, macos]\n    const size = Uint32Array.BYTES_PER_ELEMENT;\n    const head = new DataView(buffer, 12, 13 * size);\n    const littleEndian = head.getUint32(0, true) === 0x04030201;\n    const glType = head.getUint32(1 * size, littleEndian);\n    if (glType !== 0) return console.warn('only compressed formats currently supported');\n    this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n    let width = head.getUint32(6 * size, littleEndian);\n    let height = head.getUint32(7 * size, littleEndian);\n    this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n    this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n    const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n\n    this.mipmaps = [];\n    let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n    for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n        const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n        offset += 4; // levelSize field\n        for (let face = 0; face < this.numberOfFaces; face++) {\n            const data = new Uint8Array(buffer, offset, levelSize);\n            this.mipmaps.push({ data, width, height });\n            offset += levelSize;\n            offset += 3 - ((levelSize + 3) % 4); // add padding for odd sized image\n        }\n        width = width >> 1;\n        height = height >> 1;\n    }\n}\n", "import { Texture } from '../core/Texture.js';\nimport { KTXTexture } from './KTXTexture.js';\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\n\nexport class TextureLoader {\n    static load(\n        gl,\n        {\n            src, // string or object of extension:src key-values\n            // {\n            //     pvrtc: '...ktx',\n            //     s3tc: '...ktx',\n            //     etc: '...ktx',\n            //     etc1: '...ktx',\n            //     astc: '...ktx',\n            //     webp: '...webp',\n            //     jpg: '...jpg',\n            //     png: '...png',\n            // }\n\n            // Only props relevant to KTXTexture\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            anisotropy = 0,\n\n            // For regular images\n            format = gl.RGBA,\n            internalFormat = format,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = true,\n        } = {}\n    ) {\n        const support = this.getSupportedExtensions(gl);\n        let ext = 'none';\n\n        // If src is string, determine which format from the extension\n        if (typeof src === 'string') {\n            ext = src.split('.').pop().split('?')[0].toLowerCase();\n        }\n\n        // If src is object, use supported extensions and provided list to choose best option\n        // Get first supported match, so put in order of preference\n        if (typeof src === 'object') {\n            for (const prop in src) {\n                if (support.includes(prop.toLowerCase())) {\n                    ext = prop.toLowerCase();\n                    src = src[prop];\n                    break;\n                }\n            }\n        }\n\n        // Stringify props\n        const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id;\n\n        // Check cache for existing texture\n        if (cache[cacheID]) return cache[cacheID];\n\n        let texture;\n        switch (ext) {\n            case 'ktx':\n            case 'pvrtc':\n            case 's3tc':\n            case 'etc':\n            case 'etc1':\n            case 'astc':\n                // Load compressed texture using KTX format\n                texture = new KTXTexture(gl, {\n                    src,\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                    minFilter,\n                    magFilter,\n                });\n                texture.loaded = this.loadKTX(src, texture);\n                break;\n            case 'webp':\n            case 'jpg':\n            case 'jpeg':\n            case 'png':\n                texture = new Texture(gl, {\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                    format,\n                    internalFormat,\n                    generateMipmaps,\n                    minFilter,\n                    magFilter,\n                    premultiplyAlpha,\n                    unpackAlignment,\n                    flipY,\n                });\n                texture.loaded = this.loadImage(gl, src, texture, flipY);\n                break;\n            default:\n                console.warn('No supported format supplied');\n                texture = new Texture(gl);\n        }\n\n        texture.ext = ext;\n        cache[cacheID] = texture;\n        return texture;\n    }\n\n    static getSupportedExtensions(gl) {\n        if (supportedExtensions.length) return supportedExtensions;\n\n        const extensions = {\n            pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc'),\n            // etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n            astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc'),\n            bc7: gl.renderer.getExtension('EXT_texture_compression_bptc'),\n        };\n\n        for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\n\n        // Formats supported by all\n        supportedExtensions.push('png', 'jpg', 'webp');\n\n        return supportedExtensions;\n    }\n\n    static loadKTX(src, texture) {\n        return fetch(src)\n            .then((res) => res.arrayBuffer())\n            .then((buffer) => texture.parseBuffer(buffer));\n    }\n\n    static loadImage(gl, src, texture, flipY) {\n        return decodeImage(src, flipY).then((imgBmp) => {\n            // Catch non POT textures for WebGL1 and update params to avoid errors\n            if (!gl.renderer.isWebgl2 && (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height))) {\n                if (texture.generateMipmaps) texture.generateMipmaps = false;\n                if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n                if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n            }\n\n            texture.image = imgBmp;\n\n            // For createImageBitmap, close once uploaded\n            texture.onUpdate = () => {\n                if (imgBmp.close) imgBmp.close();\n                texture.onUpdate = null;\n            };\n\n            return imgBmp;\n        });\n    }\n\n    static clearCache() {\n        cache = {};\n    }\n}\n\nfunction powerOfTwo(value) {\n    // (width & (width - 1)) !== 0\n    return Math.log2(value) % 1 === 0;\n}\n\nfunction decodeImage(src, flipY) {\n    return new Promise((resolve, reject) => {\n        if (isCreateImageBitmap()) {\n            fetch(src, { mode: 'cors' })\n                .then((r) => r.blob())\n                .then((b) => createImageBitmap(b, { imageOrientation: flipY ? 'flipY' : 'none', premultiplyAlpha: 'none' }))\n                .then(resolve)\n                .catch((err) => reject(err));\n        } else {\n            const img = new Image();\n\n            img.crossOrigin = '';\n            img.src = src;\n            img.onerror = ({ type }) => reject(`${type}: Loading image`);\n            img.onload = () => resolve(img);\n        }\n    });\n}\n\nfunction isCreateImageBitmap() {\n    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n    if (!isChrome) return false;\n    try {\n        createImageBitmap;\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst identity = /* @__PURE__ */ new Mat4();\n\nexport class GLTFSkin extends Mesh {\n    constructor(gl, { skeleton, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n        this.skeleton = skeleton;\n        this.program = program;\n        this.createBoneTexture();\n    }\n\n    createBoneTexture() {\n        if (!this.skeleton.joints.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    updateUniforms() {\n        // Update bone texture\n        this.skeleton.joints.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        this.boneTexture.needsUpdate = true;\n        // Reset for programs shared between multiple skins\n        this.program.uniforms.boneTexture.value = this.boneTexture;\n        this.program.uniforms.boneTextureSize.value = this.boneTextureSize;\n    }\n\n    draw({ camera } = {}) {\n        if (!this.program.uniforms.boneTexture) {\n            Object.assign(this.program.uniforms, {\n                boneTexture: { value: this.boneTexture },\n                boneTextureSize: { value: this.boneTextureSize },\n            });\n        }\n\n        this.updateUniforms();\n\n        // Switch the world matrix with identity to ignore any transforms\n        // on the mesh itself - only use skeleton's transforms\n        const _worldMatrix = this.worldMatrix;\n        this.worldMatrix = identity;\n\n        super.draw({ camera });\n\n        // Switch back to leave identity untouched\n        this.worldMatrix = _worldMatrix;\n    }\n}\n", "import { Transform } from '../core/Transform.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec4 } from '../math/Vec4.js';\n\nexport class InstancedMesh extends Mesh {\n    constructor(...args) {\n        super(...args);\n\n        // Skip renderer frustum culling\n        this.frustumCulled = false;\n        this.isInstancedMesh = true;\n    }\n\n    addFrustumCull() {\n        this.instanceTransforms = null;\n        this.instanceLightmapScaleOffset = null;\n        this.totalInstanceCount = 0;\n        this.frustumCullFunction = null;\n        this.instanceRenderList = null;\n\n        // Get instanced mesh\n        if (!this.geometry.attributes.instanceMatrix)\n            console.error(`mesh ${this.name ? `\"${this.name}\" ` : ``}missing instanceMatrix attribute; unable to frustum cull`);\n\n        // Make list of transforms from instanceMatrix\n        const matrixData = this.geometry.attributes.instanceMatrix.data;\n        this.instanceTransforms = [];\n        for (let i = 0, j = 0; i < matrixData.length; i += 16, j++) {\n            const transform = new Transform();\n            transform.index = j;\n            transform.matrix.fromArray(matrixData, i);\n            transform.decompose();\n            this.instanceTransforms.push(transform);\n            // Add transforms to parent to update world matrices\n            transform.setParent(this.parent);\n        }\n        this.totalInstanceCount = this.instanceTransforms.length;\n\n        // Check for lightmap attributes - attach to transform\n        if (!!this.geometry.attributes.lightmapScaleOffset) {\n            const lightmapData = this.geometry.attributes.lightmapScaleOffset.data;\n            for (let i = 0, j = 0; i < lightmapData.length; i += 4, j++) {\n                this.instanceTransforms[j].lightmapData = new Vec4().fromArray(lightmapData, i);\n            }\n        }\n\n        this.frustumCullFunction = ({ camera }) => {\n            // frustum cull transforms each frame - pass world matrix\n            this.instanceRenderList = [];\n            this.instanceTransforms.forEach((transform) => {\n                if (!camera.frustumIntersectsMesh(this, transform.worldMatrix)) return;\n                this.instanceRenderList.push(transform);\n            });\n\n            // update instanceMatrix and instancedCount with visible\n            this.instanceRenderList.forEach((transform, i) => {\n                transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n                // Update lightmap attr\n                if (transform.lightmapData) {\n                    transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                    this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                }\n            });\n            this.geometry.instancedCount = this.instanceRenderList.length;\n            this.geometry.attributes.instanceMatrix.needsUpdate = true;\n        };\n\n        this.onBeforeRender(this.frustumCullFunction);\n    }\n\n    removeFrustumCull() {\n        this.offBeforeRender(this.frustumCullFunction);\n        this.geometry.instancedCount = this.totalInstanceCount;\n        this.instanceTransforms.forEach((transform, i) => {\n            transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n            // Update lightmap attr\n            if (transform.lightmapData) {\n                transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n            }\n        });\n        this.geometry.attributes.instanceMatrix.needsUpdate = true;\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Camera } from '../core/Camera.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { NormalProgram } from './NormalProgram.js';\nimport { InstancedMesh } from './InstancedMesh.js';\n\n// TODO\n// [ ] Morph targets\n// [ ] Materials\n// [ ] Sparse accessor packing? For morph targets basically\n// [ ] Option to turn off GPU instancing?\n// [ ] Spot lights\n\nconst TYPE_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n    'image/jpeg': Uint8Array,\n    'image/png': Uint8Array,\n    'image/webp': Uint8Array,\n};\n\nconst TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n};\n\nconst TRANSFORMS = {\n    translation: 'position',\n    rotation: 'quaternion',\n    scale: 'scale',\n};\n\nexport class GLTFLoader {\n    static setDracoManager(manager) {\n        this.dracoManager = manager;\n    }\n\n    static setBasisManager(manager) {\n        this.basisManager = manager;\n    }\n\n    static async load(gl, src) {\n        const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n        // Load main description json\n        const desc = await this.parseDesc(src);\n\n        return this.parse(gl, desc, dir);\n    }\n\n    static async parse(gl, desc, dir) {\n        if (desc.asset === undefined || desc.asset.version[0] < 2)\n            console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n\n        if (desc.extensionsRequired?.includes('KHR_draco_mesh_compression') && !this.dracoManager)\n            console.warn('KHR_draco_mesh_compression extension required but no manager supplied. Use .setDracoManager()');\n\n        if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager)\n            console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n        // Load buffers async\n        const buffers = await this.loadBuffers(desc, dir);\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        gl.renderer.bindVertexArray(null);\n\n        // Create gl buffers from bufferViews\n        const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n        // Create images from either bufferViews or separate image files\n        const images = await this.parseImages(gl, desc, dir, bufferViews);\n\n        const textures = this.parseTextures(gl, desc, images);\n\n        // Just pass through material data for now\n        const materials = this.parseMaterials(gl, desc, textures);\n\n        // Fetch the inverse bind matrices for skeleton joints\n        const skins = this.parseSkins(gl, desc, bufferViews);\n\n        // Create geometries for each mesh primitive\n        const meshes = await this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n        // Create transforms, meshes and hierarchy\n        const [nodes, cameras] = this.parseNodes(gl, desc, meshes, skins, images);\n\n        // Place nodes in skeletons\n        this.populateSkins(skins, nodes);\n\n        // Create animation handlers\n        const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n        // Get top level nodes for each scene\n        const scenes = this.parseScenes(desc, nodes);\n        const scene = scenes[desc.scene];\n\n        // Create uniforms for scene lights (TODO: light linking?)\n        const lights = this.parseLights(gl, desc, nodes, scenes);\n\n        // Remove null nodes (instanced transforms)\n        for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n        return {\n            json: desc,\n            buffers,\n            bufferViews,\n            cameras,\n            images,\n            textures,\n            materials,\n            meshes,\n            nodes,\n            lights,\n            animations,\n            scenes,\n            scene,\n        };\n    }\n\n    static parseDesc(src) {\n        return fetch(src, { mode: 'cors' })\n            .then((res) => res.arrayBuffer())\n            .then((data) => {\n                const textDecoder = new TextDecoder();\n                if (textDecoder.decode(new Uint8Array(data, 0, 4)) === 'glTF') {\n                    return this.unpackGLB(data);\n                } else {\n                    return JSON.parse(textDecoder.decode(data));\n                }\n            });\n    }\n\n    // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n    static unpackGLB(glb) {\n        // Decode and verify GLB header\n        const header = new Uint32Array(glb, 0, 3);\n        if (header[0] !== 0x46546c67) {\n            throw new Error('Invalid glTF asset.');\n        } else if (header[1] !== 2) {\n            throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n        }\n        // Decode and verify chunk headers\n        const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        if (jsonChunkHeader[1] !== 0x4e4f534a) {\n            throw new Error('Unexpected GLB layout.');\n        }\n\n        // Decode JSON\n        const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n        const json = JSON.parse(jsonText);\n        // JSON only\n        if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n\n        const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n        if (binaryChunkHeader[1] !== 0x004e4942) {\n            throw new Error('Unexpected GLB layout.');\n        }\n        // Decode content\n        const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n        const binaryByteLength = binaryChunkHeader[0];\n        const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n        // Attach binary to buffer\n        json.buffers[0].binary = binary;\n        return json;\n    }\n\n    // ThreeJS GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n    static resolveURI(uri, dir) {\n        // Invalid URI\n        if (typeof uri !== 'string' || uri === '') return '';\n\n        // Host Relative URI\n        if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n            dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n        }\n\n        // Absolute URI http://, https://, //\n        if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n        // Data URI\n        if (/^data:.*,.*$/i.test(uri)) return uri;\n\n        // Blob URI\n        if (/^blob:.*$/i.test(uri)) return uri;\n\n        // Relative URI\n        return dir + uri;\n    }\n\n    static loadBuffers(desc, dir) {\n        if (!desc.buffers) return null;\n        return Promise.all(\n            desc.buffers.map((buffer) => {\n                // For GLB, binary buffer ready to go\n                if (buffer.binary) return buffer.binary;\n                const uri = this.resolveURI(buffer.uri, dir);\n                return fetch(uri, { mode: 'cors' }).then((res) => res.arrayBuffer());\n            })\n        );\n    }\n\n    static parseBufferViews(gl, desc, buffers) {\n        if (!desc.bufferViews) return null;\n        const bufferViews = desc.bufferViews;\n\n        desc.meshes &&\n            desc.meshes.forEach(({ primitives }) => {\n                primitives.forEach(({ attributes, indices, extensions }) => {\n                    // Flag bufferView as an attribute, so it knows to create a gl buffer\n                    for (const attr in attributes) {\n                        const accessor = desc.accessors[attributes[attr]];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n                    }\n\n                    if (indices !== undefined) {\n                        const accessor = desc.accessors[indices];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n\n                        // Make sure indices bufferView have a target property for gl buffer binding\n                        bufferViews[accessor.bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n                    }\n                });\n            });\n\n        // Get componentType of each bufferView from the accessors\n        desc.accessors.forEach(({ bufferView: bufferViewIndex, componentType }) => {\n            if (bufferViewIndex === undefined) return;\n            bufferViews[bufferViewIndex].componentType = componentType;\n        });\n\n        // Get mimetype of bufferView from images\n        desc.images &&\n            desc.images.forEach(({ uri, bufferView: bufferViewIndex, mimeType }) => {\n                if (bufferViewIndex === undefined) return;\n                bufferViews[bufferViewIndex].mimeType = mimeType;\n            });\n\n        // Push each bufferView to the GPU as a separate buffer\n        bufferViews.forEach(\n            (\n                {\n                    buffer: bufferIndex, // required\n                    byteOffset = 0, // optional\n                    byteLength, // required\n                    byteStride, // optional\n                    target = gl.ARRAY_BUFFER, // optional, added above for elements\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n\n                    componentType, // optional, added from accessor above\n                    mimeType, // optional, added from images above\n                    isAttribute,\n                    isDraco,\n                },\n                i\n            ) => {\n                bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n\n                if (!isAttribute || isDraco) return;\n                // Create gl buffers for the bufferView, pushing it to the GPU\n                const buffer = gl.createBuffer();\n                gl.bindBuffer(target, buffer);\n                gl.renderer.state.boundBuffer = buffer;\n                gl.bufferData(target, bufferViews[i].data, gl.STATIC_DRAW);\n                bufferViews[i].buffer = buffer;\n            }\n        );\n\n        return bufferViews;\n    }\n\n    static parseImages(gl, desc, dir, bufferViews) {\n        if (!desc.images) return null;\n        return Promise.all(\n            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {\n                if (mimeType === 'image/ktx2') {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const image = await this.basisManager.parseTexture(data);\n                    return image;\n                }\n\n                // jpg / png / webp\n                const image = new Image();\n                image.name = name;\n                if (uri) {\n                    image.src = this.resolveURI(uri, dir);\n                } else if (bufferViewIndex !== undefined) {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const blob = new Blob([data], { type: mimeType });\n                    image.src = URL.createObjectURL(blob);\n                }\n                image.ready = new Promise((res) => {\n                    image.onload = () => res();\n                });\n                return image;\n            })\n        );\n    }\n\n    static parseTextures(gl, desc, images) {\n        if (!desc.textures) return null;\n        return desc.textures.map((textureInfo) => this.createTexture(gl, desc, images, textureInfo));\n    }\n\n    static createTexture(gl, desc, images, { sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) {\n        if (sourceIndex === undefined && !!extensions) {\n            // WebP extension source index\n            if (extensions.EXT_texture_webp) sourceIndex = extensions.EXT_texture_webp.source;\n\n            // Basis extension source index\n            if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n        }\n\n        const image = images[sourceIndex];\n        if (image.texture) return image.texture;\n\n        const options = {\n            flipY: false,\n            wrapS: gl.REPEAT, // Repeat by default, opposed to OGL's clamp by default\n            wrapT: gl.REPEAT,\n        };\n        const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n        if (sampler) {\n            ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {\n                if (sampler[prop]) options[prop] = sampler[prop];\n            });\n        }\n\n        // For compressed textures\n        if (image.isBasis) {\n            options.image = image;\n            options.internalFormat = image.internalFormat;\n            if (image.isCompressedTexture) {\n                options.generateMipmaps = false;\n                if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n            }\n            const texture = new Texture(gl, options);\n            texture.name = name;\n            image.texture = texture;\n            return texture;\n        }\n\n        const texture = new Texture(gl, options);\n        texture.name = name;\n        image.texture = texture;\n        image.ready.then(() => {\n            texture.image = image;\n        });\n\n        return texture;\n    }\n\n    static parseMaterials(gl, desc, textures) {\n        if (!desc.materials) return null;\n        return desc.materials.map(\n            ({\n                name,\n                extensions,\n                extras,\n                pbrMetallicRoughness = {},\n                normalTexture,\n                occlusionTexture,\n                emissiveTexture,\n                emissiveFactor = [0, 0, 0],\n                alphaMode = 'OPAQUE',\n                alphaCutoff = 0.5,\n                doubleSided = false,\n            }) => {\n                const {\n                    baseColorFactor = [1, 1, 1, 1],\n                    baseColorTexture,\n                    metallicFactor = 1,\n                    roughnessFactor = 1,\n                    metallicRoughnessTexture,\n                    //   extensions,\n                    //   extras,\n                } = pbrMetallicRoughness;\n\n                if (baseColorTexture) {\n                    baseColorTexture.texture = textures[baseColorTexture.index];\n                    // texCoord\n                }\n                if (normalTexture) {\n                    normalTexture.texture = textures[normalTexture.index];\n                    // scale: 1\n                    // texCoord\n                }\n                if (metallicRoughnessTexture) {\n                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n                    // texCoord\n                }\n                if (occlusionTexture) {\n                    occlusionTexture.texture = textures[occlusionTexture.index];\n                    // strength 1\n                    // texCoord\n                }\n                if (emissiveTexture) {\n                    emissiveTexture.texture = textures[emissiveTexture.index];\n                    // texCoord\n                }\n\n                return {\n                    name,\n                    extensions,\n                    extras,\n                    baseColorFactor,\n                    baseColorTexture,\n                    metallicFactor,\n                    roughnessFactor,\n                    metallicRoughnessTexture,\n                    normalTexture,\n                    occlusionTexture,\n                    emissiveTexture,\n                    emissiveFactor,\n                    alphaMode,\n                    alphaCutoff,\n                    doubleSided,\n                };\n            }\n        );\n    }\n\n    static parseSkins(gl, desc, bufferViews) {\n        if (!desc.skins) return null;\n        return desc.skins.map(\n            ({\n                inverseBindMatrices, // optional\n                skeleton, // optional\n                joints, // required\n                // name,\n                // extensions,\n                // extras,\n            }) => {\n                return {\n                    inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n                    skeleton,\n                    joints,\n                };\n            }\n        );\n    }\n\n    static parseMeshes(gl, desc, bufferViews, materials, skins) {\n        if (!desc.meshes) return null;\n        return Promise.all(\n            desc.meshes.map(\n                async (\n                    {\n                        primitives, // required\n                        weights, // optional\n                        name, // optional\n                        extensions, // optional\n                        extras = {}, // optional - will get merged with node extras\n                    },\n                    meshIndex\n                ) => {\n                    // TODO: weights stuff?\n                    // Parse through nodes to see how many instances there are and if there is a skin attached\n                    // If multiple instances of a skin, need to create each\n                    let numInstances = 0;\n                    let skinIndices = [];\n                    let isLightmap = false;\n                    desc.nodes &&\n                        desc.nodes.forEach(({ mesh, skin, extras }) => {\n                            if (mesh === meshIndex) {\n                                numInstances++;\n                                if (skin !== undefined) skinIndices.push(skin);\n                                if (extras && extras.lightmap_scale_offset) isLightmap = true;\n                            }\n                        });\n                    let isSkin = !!skinIndices.length;\n\n                    // For skins, return array of skin meshes to account for multiple instances\n                    if (isSkin) {\n                        primitives = await Promise.all(\n                            skinIndices.map(async (skinIndex) => {\n                                return (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, 1, isLightmap)).map(({ geometry, program, mode }) => {\n                                    const mesh = new GLTFSkin(gl, { skeleton: skins[skinIndex], geometry, program, mode });\n                                    mesh.name = name;\n                                    mesh.extras = extras;\n                                    if (extensions) mesh.extensions = extensions;\n                                    // TODO: support skin frustum culling\n                                    mesh.frustumCulled = false;\n                                    return mesh;\n                                });\n                            })\n                        );\n                        // For retrieval to add to node\n                        primitives.instanceCount = 0;\n                        primitives.numInstances = numInstances;\n                    } else {\n                        primitives = (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap)).map(({ geometry, program, mode }) => {\n                            // InstancedMesh class has custom frustum culling for instances\n                            const meshConstructor = geometry.attributes.instanceMatrix ? InstancedMesh : Mesh;\n                            const mesh = new meshConstructor(gl, { geometry, program, mode });\n                            mesh.name = name;\n                            mesh.extras = extras;\n                            if (extensions) mesh.extensions = extensions;\n                            // Tag mesh so that nodes can add their transforms to the instance attribute\n                            mesh.numInstances = numInstances;\n                            return mesh;\n                        });\n                    }\n\n                    return {\n                        primitives,\n                        weights,\n                        name,\n                    };\n                }\n            )\n        );\n    }\n\n    static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap) {\n        return Promise.all(\n            primitives.map(\n                async ({\n                    attributes, // required\n                    indices, // optional\n                    material: materialIndex, // optional\n                    mode = 4, // optional\n                    targets, // optional\n                    extensions, // optional\n                    extras, // optional\n                }) => {\n                    // TODO: materials\n                    const program = new NormalProgram(gl);\n                    if (materialIndex !== undefined) {\n                        program.gltfMaterial = materials[materialIndex];\n                    }\n\n                    const geometry = new Geometry(gl);\n                    if (extras) geometry.extras = extras;\n                    if (extensions) geometry.extensions = extensions;\n\n                    // For compressed geometry data\n                    if (extensions && extensions.KHR_draco_mesh_compression) {\n                        const bufferViewIndex = extensions.KHR_draco_mesh_compression.bufferView;\n                        const gltfAttributeMap = extensions.KHR_draco_mesh_compression.attributes;\n                        const attributeMap = {};\n                        const attributeTypeMap = {};\n                        const attributeTypeNameMap = {};\n                        const attributeNormalizedMap = {};\n\n                        for (const attr in attributes) {\n                            const accessor = desc.accessors[attributes[attr]];\n                            const attributeName = ATTRIBUTES[attr];\n                            attributeMap[attributeName] = gltfAttributeMap[attr];\n                            attributeTypeMap[attributeName] = accessor.componentType;\n                            attributeTypeNameMap[attributeName] = TYPE_ARRAY[accessor.componentType].name;\n                            attributeNormalizedMap[attributeName] = accessor.normalized === true;\n                        }\n\n                        const { data } = bufferViews[bufferViewIndex];\n                        const geometryData = await this.dracoManager.decodeGeometry(data, {\n                            attributeIds: attributeMap,\n                            attributeTypes: attributeTypeNameMap,\n                        });\n\n                        // Add each attribute result\n                        for (let i = 0; i < geometryData.attributes.length; i++) {\n                            const result = geometryData.attributes[i];\n                            const name = result.name;\n                            const data = result.array;\n                            const size = result.itemSize;\n                            const type = attributeTypeMap[name];\n                            const normalized = attributeNormalizedMap[name];\n\n                            // Create gl buffers for the attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute(name, {\n                                data,\n                                size,\n                                type,\n                                normalized,\n                                buffer,\n                            });\n                        }\n\n                        // Add index attribute if found\n                        if (geometryData.index) {\n                            const data = geometryData.index.array;\n                            const size = geometryData.index.itemSize;\n\n                            // Create gl buffers for the index attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute('index', {\n                                data,\n                                size,\n                                type: 5125, // Uint32Array\n                                normalized: false,\n                                buffer,\n                            });\n                        }\n                    } else {\n                        // Add each attribute found in primitive\n                        for (const attr in attributes) {\n                            geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n                        }\n\n                        // Add index attribute if found\n                        if (indices !== undefined) {\n                            geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n                        }\n                    }\n\n                    // Add instanced transform attribute if multiple instances\n                    // Ignore if skin as we don't support instanced skins out of the box\n                    if (numInstances > 1) {\n                        geometry.addAttribute('instanceMatrix', {\n                            instanced: 1,\n                            size: 16,\n                            data: new Float32Array(numInstances * 16),\n                        });\n                    }\n\n                    // Always supply lightmapScaleOffset as an instanced attribute\n                    // Instanced skin lightmaps not supported\n                    if (isLightmap) {\n                        geometry.addAttribute('lightmapScaleOffset', {\n                            instanced: 1,\n                            size: 4,\n                            data: new Float32Array(numInstances * 4),\n                        });\n                    }\n\n                    return {\n                        geometry,\n                        program,\n                        mode,\n                    };\n                }\n            )\n        );\n    }\n\n    static parseAccessor(index, desc, bufferViews) {\n        // TODO: init missing bufferView with 0s\n        // TODO: support sparse\n\n        const {\n            bufferView: bufferViewIndex, // optional\n            byteOffset = 0, // optional\n            componentType, // required\n            normalized = false, // optional\n            count, // required\n            type, // required\n            min, // optional\n            max, // optional\n            sparse, // optional\n            // name, // optional\n            // extensions, // optional\n            // extras, // optional\n        } = desc.accessors[index];\n\n        const {\n            data, // attached in parseBufferViews\n            buffer, // replaced to be the actual GL buffer\n            byteOffset: bufferByteOffset = 0,\n            // byteLength, // applied in parseBufferViews\n            byteStride = 0,\n            target,\n            // name,\n            // extensions,\n            // extras,\n        } = bufferViews[bufferViewIndex];\n\n        const size = TYPE_SIZE[type];\n\n        // Parse data from joined buffers\n        const TypeArray = TYPE_ARRAY[componentType];\n        const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n        const componentStride = byteStride / elementBytes;\n        const isInterleaved = !!byteStride && componentStride !== size;\n\n        let filteredData;\n\n        // Convert data to typed array for various uses (bounding boxes, raycasting, animation, merging etc)\n        if (isInterleaved) {\n            // First convert entire buffer to type\n            const typedData = new TypeArray(data, byteOffset);\n            // TODO: add length to not copy entire buffer if can help it\n            // const typedData = new TypeArray(data, byteOffset, (count - 1) * componentStride)\n\n            // Create output with length\n            filteredData = new TypeArray(count * size);\n\n            // Add element by element\n            for (let i = 0; i < count; i++) {\n                const start = componentStride * i;\n                const end = start + size;\n                filteredData.set(typedData.slice(start, end), i * size);\n            }\n        } else {\n            // Simply a slice\n            filteredData = new TypeArray(data, byteOffset, count * size);\n        }\n\n        // Return attribute data\n        return {\n            data: filteredData,\n            size,\n            type: componentType,\n            normalized,\n            buffer,\n            stride: byteStride,\n            offset: byteOffset,\n            count,\n            min,\n            max,\n        };\n    }\n\n    static parseNodes(gl, desc, meshes, skins, images) {\n        if (!desc.nodes) return null;\n        const cameras = [];\n        const nodes = desc.nodes.map(\n            ({\n                camera, // optional\n                children, // optional\n                skin: skinIndex, // optional\n                matrix, // optional\n                mesh: meshIndex, // optional\n                rotation, // optional\n                scale, // optional\n                translation, // optional\n                weights, // optional\n                name, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const isCamera = camera !== undefined;\n\n                const node = isCamera ? new Camera(gl) : new Transform();\n\n                if (isCamera) {\n                    // NOTE: chose to use node's name and extras/extensions over camera\n                    const cameraOpts = desc.cameras[camera];\n                    if (cameraOpts.type === 'perspective') {\n                        const { yfov: fov, znear: near, zfar: far } = cameraOpts.perspective;\n                        node.perspective({ fov: fov * (180 / Math.PI), near, far });\n                    } else {\n                        const { xmag, ymag, znear: near, zfar: far } = cameraOpts.orthographic;\n                        node.orthographic({ near, far, left: -xmag, right: xmag, top: -ymag, bottom: ymag });\n                    }\n                    cameras.push(node);\n                }\n\n                if (name) node.name = name;\n                if (extras) node.extras = extras;\n                if (extensions) node.extensions = extensions;\n\n                // Need to attach to node as may have same material but different lightmap\n                if (extras && extras.lightmapTexture !== undefined) {\n                    extras.lightmapTexture.texture = this.createTexture(gl, desc, images, { source: extras.lightmapTexture.index });\n                }\n\n                // Apply transformations\n                if (matrix) {\n                    node.matrix.copy(matrix);\n                    node.decompose();\n                } else {\n                    if (rotation) node.quaternion.copy(rotation);\n                    if (scale) node.scale.copy(scale);\n                    if (translation) node.position.copy(translation);\n                    node.updateMatrix();\n                }\n\n                // Flags for avoiding duplicate transforms and removing unused instance nodes\n                let isInstanced = false;\n                let isFirstInstance = true;\n                let isInstancedMatrix = false;\n                let isSkin = skinIndex !== undefined;\n\n                // Add mesh if included\n                if (meshIndex !== undefined) {\n                    if (isSkin) {\n                        meshes[meshIndex].primitives[meshes[meshIndex].primitives.instanceCount].forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n                            mesh.setParent(node);\n                        });\n                        meshes[meshIndex].primitives.instanceCount++;\n                        // Remove properties once all instances added\n                        if (meshes[meshIndex].primitives.instanceCount === meshes[meshIndex].primitives.numInstances) {\n                            delete meshes[meshIndex].primitives.numInstances;\n                            delete meshes[meshIndex].primitives.instanceCount;\n                        }\n                    } else {\n                        meshes[meshIndex].primitives.forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n\n                            // Instanced mesh might only have 1\n                            if (mesh.geometry.isInstanced) {\n                                isInstanced = true;\n                                if (!mesh.instanceCount) {\n                                    mesh.instanceCount = 0;\n                                } else {\n                                    isFirstInstance = false;\n                                }\n                                if (mesh.geometry.attributes.instanceMatrix) {\n                                    isInstancedMatrix = true;\n                                    node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n                                }\n\n                                if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                    mesh.geometry.attributes.lightmapScaleOffset.data.set(extras.lightmap_scale_offset, mesh.instanceCount * 4);\n                                }\n\n                                mesh.instanceCount++;\n\n                                if (mesh.instanceCount === mesh.numInstances) {\n                                    // Remove properties once all instances added\n                                    delete mesh.numInstances;\n                                    delete mesh.instanceCount;\n                                    // Flag attribute as dirty\n                                    if (mesh.geometry.attributes.instanceMatrix) {\n                                        mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                                    }\n                                    if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                        mesh.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                                    }\n                                }\n                            }\n\n                            // For instances, only the first node will actually have the mesh\n                            if (isInstanced) {\n                                if (isFirstInstance) mesh.setParent(node);\n                            } else {\n                                mesh.setParent(node);\n                            }\n                        });\n                    }\n                }\n\n                // Reset node if instanced to not duplicate transforms\n                if (isInstancedMatrix) {\n                    // Remove unused nodes just providing an instance transform\n                    if (!isFirstInstance) return null;\n                    // Avoid duplicate transform for node containing the instanced mesh\n                    node.matrix.identity();\n                    node.decompose();\n                }\n\n                return node;\n            }\n        );\n\n        desc.nodes.forEach(({ children = [] }, i) => {\n            // Set hierarchy now all nodes created\n            children.forEach((childIndex) => {\n                if (!nodes[childIndex]) return;\n                nodes[childIndex].setParent(nodes[i]);\n            });\n        });\n\n        // Add frustum culling for instances now that instanceMatrix attribute is populated\n        meshes.forEach(({ primitives }, i) => {\n            primitives.forEach((primitive, i) => {\n                if (primitive.isInstancedMesh) primitive.addFrustumCull();\n            });\n        });\n\n        return [nodes, cameras];\n    }\n\n    static populateSkins(skins, nodes) {\n        if (!skins) return;\n        skins.forEach((skin) => {\n            skin.joints = skin.joints.map((i, index) => {\n                const joint = nodes[i];\n                joint.skin = skin;\n                joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n                return joint;\n            });\n            if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n        });\n    }\n\n    static parseAnimations(gl, desc, nodes, bufferViews) {\n        if (!desc.animations) return null;\n        return desc.animations.map(\n            (\n                {\n                    channels, // required\n                    samplers, // required\n                    name, // optional\n                    // extensions, // optional\n                    // extras,  // optional\n                },\n                animationIndex\n            ) => {\n                const data = channels.map(\n                    ({\n                        sampler: samplerIndex, // required\n                        target, // required\n                        // extensions, // optional\n                        // extras, // optional\n                    }) => {\n                        const {\n                            input: inputIndex, // required\n                            interpolation = 'LINEAR',\n                            output: outputIndex, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = samplers[samplerIndex];\n\n                        const {\n                            node: nodeIndex, // optional - TODO: when is it not included?\n                            path, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = target;\n\n                        const node = nodes[nodeIndex];\n                        const transform = TRANSFORMS[path];\n                        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n                        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n                        // Store reference on node for cyclical retrieval\n                        if (!node.animations) node.animations = [];\n                        if (!node.animations.includes(animationIndex)) node.animations.push(animationIndex);\n\n                        return {\n                            node,\n                            transform,\n                            interpolation,\n                            times,\n                            values,\n                        };\n                    }\n                );\n\n                return {\n                    name,\n                    animation: new GLTFAnimation(data),\n                };\n            }\n        );\n    }\n\n    static parseScenes(desc, nodes) {\n        if (!desc.scenes) return null;\n        return desc.scenes.map(\n            ({\n                nodes: nodesIndices = [],\n                name, // optional\n                extensions,\n                extras,\n            }) => {\n                const scene = nodesIndices.reduce((map, i) => {\n                    // Don't add null nodes (instanced transforms)\n                    if (nodes[i]) map.push(nodes[i]);\n                    return map;\n                }, []);\n                scene.extras = extras;\n                return scene;\n            }\n        );\n    }\n\n    static parseLights(gl, desc, nodes, scenes) {\n        const lights = {\n            directional: [],\n            point: [],\n            spot: [],\n        };\n\n        // Update matrices on root nodes\n        scenes.forEach((scene) => scene.forEach((node) => node.updateMatrixWorld()));\n\n        // Uses KHR_lights_punctual extension\n        const lightsDescArray = desc.extensions?.KHR_lights_punctual?.lights || [];\n\n        // Need nodes for transforms\n        nodes.forEach((node) => {\n            if (!node?.extensions?.KHR_lights_punctual) return;\n            const lightIndex = node.extensions.KHR_lights_punctual.light;\n            const lightDesc = lightsDescArray[lightIndex];\n            const light = {\n                name: lightDesc.name || '',\n                color: { value: new Vec3().set(lightDesc.color || 1) },\n            };\n            // Apply intensity directly to color\n            if (lightDesc.intensity !== undefined) light.color.value.multiply(lightDesc.intensity);\n\n            switch (lightDesc.type) {\n                case 'directional':\n                    light.direction = { value: new Vec3(0, 0, 1).transformDirection(node.worldMatrix) };\n                    break;\n                case 'point':\n                    light.position = { value: new Vec3().applyMatrix4(node.worldMatrix) };\n                    light.distance = { value: lightDesc.range };\n                    light.decay = { value: 2 };\n                    break;\n                case 'spot':\n                    // TODO: support spot uniforms\n                    Object.assign(light, lightDesc);\n                    break;\n            }\n\n            lights[lightDesc.type].push(light);\n        });\n\n        return lights;\n    }\n}\n", "let id = 0;\n\nexport class DracoManager {\n    constructor(workerSrc) {\n        this.onMessage = this.onMessage.bind(this);\n        this.queue = new Map();\n        this.initWorker(workerSrc);\n    }\n\n    initWorker(workerSrc) {\n        this.worker = new Worker(workerSrc);\n        this.worker.onmessage = this.onMessage;\n    }\n\n    onMessage({ data }) {\n        const { id, error, geometry } = data;\n        if (error) {\n            console.log(error, id);\n            return;\n        }\n        const geometryResolve = this.queue.get(id);\n        this.queue.delete(id);\n        geometryResolve(geometry);\n    }\n\n    decodeGeometry(buffer, config) {\n        id++;\n        this.worker.postMessage({\n            id,\n            buffer,\n            config,\n        });\n        let geometryResolve;\n        const promise = new Promise((res) => (geometryResolve = res));\n        this.queue.set(id, geometryResolve);\n        return promise;\n    }\n}\n", "let supportedFormat;\nlet id = 0;\n\nexport class BasisManager {\n    constructor(workerSrc, gl) {\n        if (!supportedFormat) supportedFormat = this.getSupportedFormat(gl);\n        this.onMessage = this.onMessage.bind(this);\n        this.queue = new Map();\n        this.initWorker(workerSrc);\n    }\n\n    getSupportedFormat(gl = document.createElement('canvas').getContext('webgl')) {\n        /* if (!!gl.getExtension('WEBGL_compressed_texture_etc')) {\n            return 'etc2';\n        } else  */\n        if (!!gl.getExtension('WEBGL_compressed_texture_astc')) {\n            return 'astc';\n        } else if (!!gl.getExtension('EXT_texture_compression_bptc')) {\n            return 'bptc';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_s3tc')) {\n            return 's3tc';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_etc1')) {\n            return 'etc1';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_pvrtc') || !!gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')) {\n            return 'pvrtc';\n            // } else if (!!gl.getExtension('WEBGL_compressed_texture_atc')) {\n            //     return 'atc';\n        }\n        return 'none';\n    }\n\n    initWorker(workerSrc) {\n        this.worker = new Worker(workerSrc);\n        this.worker.onmessage = this.onMessage;\n    }\n\n    onMessage({ data }) {\n        const { id, error, image } = data;\n        if (error) {\n            console.log(error, id);\n            return;\n        }\n        const textureResolve = this.queue.get(id);\n        this.queue.delete(id);\n        image.isBasis = true;\n        textureResolve(image);\n    }\n\n    parseTexture(buffer) {\n        id++;\n        this.worker.postMessage({\n            id,\n            buffer,\n            supportedFormat,\n        });\n        let textureResolve;\n        const promise = new Promise((res) => (textureResolve = res));\n        this.queue.set(id, textureResolve);\n        return promise;\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Program } from '../core/Program.js';\nimport { Geometry } from '../core/Geometry.js';\nimport { Color } from '../math/Color.js';\n\nexport class WireMesh extends Mesh {\n    constructor(gl, { geometry, wireColor = new Color(0, 0.75, 0.5), ...meshProps } = {}) {\n        const wireProgram = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: { wireColor: { value: wireColor } },\n        });\n\n        const positionArray = geometry.attributes.position.data;\n        const indices = [];\n        const hashSet = new Set();\n\n        function addUniqueIndices(idx) {\n            for (let i = 0; i < idx.length; i += 2) {\n                if (isUniqueEdgePosition(idx[i] * 3, idx[i + 1] * 3, positionArray, hashSet)) {\n                    indices.push(idx[i], idx[i + 1]);\n                }\n            }\n        }\n\n        if (geometry.attributes.index) {\n            const idata = geometry.attributes.index.data;\n\n            for (let i = 0; i < idata.length; i += 3) {\n                // For every triangle, make three line pairs (start, end)\n                // prettier-ignore\n                addUniqueIndices([\n                    idata[i], idata[i + 1],\n                    idata[i + 1], idata[i + 2],\n                    idata[i + 2], idata[i]\n                ]);\n            }\n        } else {\n            const numVertices = Math.floor(positionArray.length / 3);\n\n            for (let i = 0; i < numVertices; i += 3) {\n                addUniqueIndices([i, i + 1, i + 1, i + 2, i + 2, i]);\n            }\n        }\n\n        const indicesTyped = indices.length > 65536 ? new Uint32Array(indices) : new Uint16Array(indices);\n        const wireGeometry = new Geometry(gl, {\n            position: { ...geometry.attributes.position },\n            index: { data: indicesTyped },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry: wireGeometry, program: wireProgram });\n    }\n}\n\n// from https://github.com/mrdoob/three.js/blob/0c26bb4bb8220126447c8373154ac045588441de/src/geometries/WireframeGeometry.js#L116\nfunction isUniqueEdgePosition(start, end, pos, hashSet) {\n    // prettier-ignore\n    const hash1 = [\n        pos[start], pos[start + 1], pos[start + 2],\n        pos[end], pos[end + 1], pos[end + 2]\n    ].join('#');\n\n    // coincident edge\n    // prettier-ignore\n    const hash2 = [\n        pos[end], pos[end + 1], pos[end + 2],\n        pos[start], pos[start + 1], pos[start + 2]\n    ].join('#');\n\n    const oldSize = hashSet.size;\n    hashSet.add(hash1);\n    hashSet.add(hash2);\n    return hashSet.size - oldSize === 2;\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 wireColor;\n\nvoid main() {    \n    gl_FragColor = vec4(wireColor, 1.0);\n}\n`;\n", "import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\n\nexport class AxesHelper extends Mesh {\n    constructor(\n        gl,\n        {\n            size = 1,\n            symmetric = false,\n            xColor = new Vec3(0.96, 0.21, 0.32),\n            yColor = new Vec3(0.44, 0.64, 0.11),\n            zColor = new Vec3(0.18, 0.52, 0.89),\n            ...meshProps\n        } = {}\n    ) {\n        const a = symmetric ? -size : 0;\n        const b = size;\n\n        // prettier-ignore\n        const vertices = new Float32Array([\n\t\t\ta, 0, 0,  b, 0, 0,\n\t\t\t0, a, 0,  0, b, 0,\n\t\t\t0, 0, a,  0, 0, b\n\t\t]);\n\n        // prettier-ignore\n        const colors = new Float32Array([\n\t\t\t...xColor,  ...xColor,\n\t\t\t...yColor,  ...yColor,\n\t\t\t...zColor,  ...zColor\n\t\t]);\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: vertices },\n            color: { size: 3, data: colors },\n        });\n\n        const program = new Program(gl, { vertex, fragment });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 color;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec3 vColor;\n\nvoid main() {    \n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {    \n    gl_FragColor = vec4(vColor, 1.0);\n}\n`;\n", "import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\n\nexport class GridHelper extends Mesh {\n    constructor(gl, { size = 10, divisions = 10, color = new Vec3(0.75, 0.75, 0.75), ...meshProps } = {}) {\n        const numVertices = (size + 1) * 2 * 2;\n        const vertices = new Float32Array(numVertices * 3);\n\n        const hs = size / 2;\n        for (let i = 0; i <= divisions; i++) {\n            const t = i / divisions;\n            const o = t * size - hs;\n\n            vertices.set([o, 0, -hs, o, 0, hs], i * 12);\n            vertices.set([-hs, 0, o, hs, 0, o], i * 12 + 6);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: vertices },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n            },\n        });\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n", "import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { Mat3 } from '../../math/Mat3.js';\n\nexport class VertexNormalsHelper extends Mesh {\n    constructor(object, { size = 0.1, color = new Vec3(0.86, 0.16, 0.86), ...meshProps } = {}) {\n        const gl = object.gl;\n        const nNormals = object.geometry.attributes.normal.count;\n        const positionsArray = new Float32Array(nNormals * 2 * 3);\n        const normalsArray = new Float32Array(nNormals * 2 * 3);\n        const sizeArray = new Float32Array(nNormals * 2);\n\n        const normalData = object.geometry.attributes.normal.data;\n        const positionData = object.geometry.attributes.position.data;\n        const sizeData = new Float32Array([0, size]);\n\n        for (let i = 0; i < nNormals; i++) {\n            const i6 = i * 6;\n            const i3 = i * 3;\n\n            // duplicate position and normal for line start and end point\n            const pSub = positionData.subarray(i3, i3 + 3);\n            positionsArray.set(pSub, i6);\n            positionsArray.set(pSub, i6 + 3);\n\n            const nSub = normalData.subarray(i3, i3 + 3);\n            normalsArray.set(nSub, i6);\n            normalsArray.set(nSub, i6 + 3);\n\n            sizeArray.set(sizeData, i * 2);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: positionsArray },\n            normal: { size: 3, data: normalsArray },\n            size: { size: 1, data: sizeArray },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n                worldNormalMatrix: { value: new Mat3() },\n                objectWorldMatrix: { value: object.worldMatrix },\n            },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n\n        this.object = object;\n    }\n\n    draw(arg) {\n        this.program.uniforms.worldNormalMatrix.value.getNormalMatrix(this.object.worldMatrix);\n        super.draw(arg);\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 normal;\nattribute float size;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 objectWorldMatrix;\nuniform mat3 worldNormalMatrix;\n\nvoid main() {\n    vec3 n = normalize(worldNormalMatrix * normal) * size;\n    vec3 p = (objectWorldMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * viewMatrix * vec4(p + n, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n", "import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { Mat3 } from '../../math/Mat3.js';\n\nconst vA = /* @__PURE__ */ new Vec3();\nconst vB = /* @__PURE__ */ new Vec3();\nconst vC = /* @__PURE__ */ new Vec3();\nconst vCenter = /* @__PURE__ */ new Vec3();\nconst vNormal = /* @__PURE__ */ new Vec3();\n\nexport class FaceNormalsHelper extends Mesh {\n    constructor(object, { size = 0.1, color = new Vec3(0.15, 0.86, 0.86), ...meshProps } = {}) {\n        const gl = object.gl;\n\n        const positionData = object.geometry.attributes.position.data;\n        const sizeData = new Float32Array([0, size]);\n\n        const indexAttr = object.geometry.attributes.index;\n        const getIndex = indexAttr ? (i) => indexAttr.data[i] : (i) => i;\n        const numVertices = indexAttr ? indexAttr.data.length : Math.floor(positionData.length / 3);\n\n        const nNormals = Math.floor(numVertices / 3);\n        const positionsArray = new Float32Array(nNormals * 2 * 3);\n        const normalsArray = new Float32Array(nNormals * 2 * 3);\n        const sizeArray = new Float32Array(nNormals * 2);\n\n        for (let i = 0; i < numVertices; i += 3) {\n            vA.fromArray(positionData, getIndex(i + 0) * 3);\n            vB.fromArray(positionData, getIndex(i + 1) * 3);\n            vC.fromArray(positionData, getIndex(i + 2) * 3);\n\n            vCenter\n                .add(vA, vB)\n                .add(vC)\n                .multiply(1 / 3);\n\n            vA.sub(vA, vB);\n            vC.sub(vC, vB);\n            vNormal.cross(vC, vA).normalize();\n\n            // duplicate position and normal for line start and end point\n            const i2 = i * 2;\n            positionsArray.set(vCenter, i2);\n            positionsArray.set(vCenter, i2 + 3);\n\n            normalsArray.set(vNormal, i2);\n            normalsArray.set(vNormal, i2 + 3);\n            sizeArray.set(sizeData, (i / 3) * 2);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: positionsArray },\n            normal: { size: 3, data: normalsArray },\n            size: { size: 1, data: sizeArray },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n                worldNormalMatrix: { value: new Mat3() },\n                objectWorldMatrix: { value: object.worldMatrix },\n            },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n\n        this.object = object;\n    }\n\n    draw(arg) {\n        this.program.uniforms.worldNormalMatrix.value.getNormalMatrix(this.object.worldMatrix);\n        super.draw(arg);\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 normal;\nattribute float size;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 objectWorldMatrix;\nuniform mat3 worldNormalMatrix;\n\nvoid main() {\n    vec3 n = normalize(worldNormalMatrix * normal) * size;\n    vec3 p = (objectWorldMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * viewMatrix * vec4(p + n, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n", "import { Texture } from '../core/Texture.js';\n\nexport class Texture3D extends Texture {\n    constructor(gl, args) {\n        super(gl, {\n            ...args,\n            target: gl.TEXTURE_3D,\n            width: args.width ? args.width : 2,\n            height: args.height ? args.height : 2,\n        });\n\n        const image = new Image();\n        image.crossOrigin = '*';\n        image.src = args.src;\n\n        image.onload = () => {\n            let canvas = document.createElement('canvas');\n            canvas.width = image.width;\n            canvas.height = image.height;\n\n            let ctx = canvas.getContext('2d');\n            ctx.scale(1, -1);\n            ctx.translate(0, -image.height);\n            ctx.drawImage(image, 0, 0);\n            const imageData = ctx.getImageData(0, 0, image.width, image.height).data;\n\n            canvas = null;\n            ctx = null;\n            let elementCount;\n\n            switch (this.format) {\n                case gl.RED:\n                    elementCount = 1;\n                    break;\n                case gl.RG:\n                    elementCount = 2;\n                    break;\n                case gl.RGB:\n                    elementCount = 3;\n                    break;\n                default:\n                    elementCount = 4;\n                    break;\n            }\n\n            const dataCount = this.width * this.height * this.length * elementCount;\n            const data = this.type === gl.UNSIGNED_BYTE ? new Uint8Array(dataCount) : new Float32Array(dataCount);\n\n            let dataIterator = 0;\n\n            for (let z = 0; z < this.length; z++) {\n                for (let y = 0; y < this.height; y++) {\n                    for (let x = 0; x < this.width; x++) {\n                        let zOffsetX = (z % args.tileCountX) * this.width;\n                        let zOffsetY = Math.floor(z / args.tileCountX) * (this.width * this.height * args.tileCountX);\n                        let index = x + zOffsetX + (y * image.width + zOffsetY);\n\n                        const r = imageData[index * 4];\n                        const g = imageData[index * 4 + 1];\n                        const b = imageData[index * 4 + 2];\n                        const a = imageData[index * 4 + 3];\n\n                        let texel = [r, g, b, a];\n\n                        for (let i = 0; i < elementCount; i++) {\n                            if (this.type === this.gl.UNSIGNED_BYTE) {\n                                data[dataIterator++] = texel[i];\n                            } else {\n                                data[dataIterator++] = texel[i] / 255;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.image = data;\n            this.needsUpdate = true;\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["scale", "ID", "vertex", "fragment", "length", "tempVec3", "ID", "id", "copy", "set", "scale", "normalize", "dot", "multiply", "dot", "copy", "set", "dot", "normalize", "set", "copy", "normalize", "multiply", "dot", "copy", "set", "identity", "invert", "multiply", "scale", "add", "subtract", "set", "scale", "add", "subtract", "multiply", "identity", "copy", "invert", "invert", "normal", "distance", "fromQuat", "copy", "set", "identity", "invert", "multiply", "translate", "rotate", "scale", "set", "translate", "rotate", "scale", "multiply", "identity", "copy", "fromQuat", "invert", "ID", "ID", "length", "copy", "set", "add", "subtract", "multiply", "divide", "scale", "distance", "squaredDistance", "length", "squaredLength", "negate", "inverse", "normalize", "dot", "cross", "lerp", "smoothLerp", "transformMat3", "transformMat4", "exactEquals", "set", "copy", "add", "subtract", "multiply", "scale", "divide", "inverse", "length", "distance", "squaredDistance", "squaredLength", "negate", "cross", "normalize", "dot", "exactEquals", "transformMat3", "transformMat4", "lerp", "smoothLerp", "set", "copy", "normalize", "scale", "dot", "normal", "uv", "normal", "uv", "normal", "uv", "normal", "uv", "vertex", "normal", "tempVec3", "distance", "angle", "tempVec2a", "tempVec2b", "tempVec3a", "tempVec3b", "tempMat4", "distance", "a", "b", "normal", "point", "angle", "tempVec3", "tempVec3", "tempVec3", "tempVec3", "tempMat4", "normal", "angle", "vertex", "fragment", "tempMat4", "scale", "line", "id2", "vertex", "vertex", "fragment", "vertex", "defaultVertex", "fragment", "defaultFragment", "vertex", "defaultVertex", "fragment", "defaultFragment", "uv", "defaultVertex", "defaultFragment", "vertex", "fragment", "id", "size", "tempMat4", "identity", "image", "texture", "extras", "data", "scale", "i", "_a", "id", "id", "vertex", "fragment", "vertex", "fragment", "vertex", "fragment", "vertex", "fragment", "vertex", "fragment"]
}
